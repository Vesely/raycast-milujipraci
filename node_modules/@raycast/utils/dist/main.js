var $8zHUo$react = require("react");
var $8zHUo$raycastapi = require("@raycast/api");
var $8zHUo$dequallite = require("dequal/lite");
var $8zHUo$nodefs = require("node:fs");
var $8zHUo$nodepath = require("node:path");
var $8zHUo$nodecrypto = require("node:crypto");
var $8zHUo$nodechild_process = require("node:child_process");
var $8zHUo$nodebuffer = require("node:buffer");
var $8zHUo$nodestream = require("node:stream");
var $8zHUo$nodeutil = require("node:util");
var $8zHUo$nodefspromises = require("node:fs/promises");
var $8zHUo$nodestreampromises = require("node:stream/promises");
var $8zHUo$nodestring_decoder = require("node:string_decoder");
var $8zHUo$nodeevents = require("node:events");
var $8zHUo$reactjsxruntime = require("react/jsx-runtime");
var $8zHUo$nodeos = require("node:os");
var $8zHUo$nodeurl = require("node:url");


function $parcel$export(e, n, v, s) {
  Object.defineProperty(e, n, {get: v, set: s, enumerable: true, configurable: true});
}

function $parcel$interopDefault(a) {
  return a && a.__esModule ? a.default : a;
}

      var $parcel$global = globalThis;
    
$parcel$export(module.exports, "usePromise", () => $1f5338676d90e7a6$export$dd6b79aaabe7bc37);
$parcel$export(module.exports, "useCachedState", () => $4edf56917e12e612$export$14afb9e4c16377d3);
$parcel$export(module.exports, "useCachedPromise", () => $a9b0b6f46ce12461$export$b15740c74e256244);
$parcel$export(module.exports, "useFetch", () => $d1b00242b8395b80$export$d852f5f778460fa4);
$parcel$export(module.exports, "useExec", () => $1621cf84cd51e0ff$export$3f4d948c82873887);
$parcel$export(module.exports, "useStreamJSON", () => $3122cfee675f370d$export$48c74caed1925dc8);
$parcel$export(module.exports, "useSQL", () => $908f00f283581e25$export$d74ef0af94fb1db6);
$parcel$export(module.exports, "useForm", () => $c950f3189e9100ee$export$87c0cf8eb5a167e0);
$parcel$export(module.exports, "FormValidation", () => $c950f3189e9100ee$export$cd58ffd7e3880e66);
$parcel$export(module.exports, "useAI", () => $c3d9e48f722f6b4c$export$835fc3bd312a97c);
$parcel$export(module.exports, "useFrecencySorting", () => $488f69277de5b02c$export$5f452da9662a701d);
$parcel$export(module.exports, "useLocalStorage", () => $8a703970ad0447b0$export$86e2cef2561044ac);
$parcel$export(module.exports, "getAvatarIcon", () => $31a0ba4a4e2328d9$export$378f247c814d3cc9);
$parcel$export(module.exports, "getFavicon", () => $5ea808515394f474$export$30c2a0095db95d06);
$parcel$export(module.exports, "getProgressIcon", () => $a7897b4ca3fd078f$export$e7138cfc4fbdc77c);
$parcel$export(module.exports, "OAuthService", () => $bd2f41db5e016369$export$905bf243392675e9);
$parcel$export(module.exports, "withAccessToken", () => $335119ff9d5923ac$export$d6bc6f4110e73ed6);
$parcel$export(module.exports, "getAccessToken", () => $335119ff9d5923ac$export$84773cc9bf7dbe87);
$parcel$export(module.exports, "createDeeplink", () => $7cabae6fedcce1d1$export$c4dc2df9fd7350e0);
$parcel$export(module.exports, "createExtensionDeeplink", () => $7cabae6fedcce1d1$export$ddb13afcb01cd60d);
$parcel$export(module.exports, "createScriptCommandDeeplink", () => $7cabae6fedcce1d1$export$f537f4c2068da401);
$parcel$export(module.exports, "DeeplinkType", () => $7cabae6fedcce1d1$export$a7e8ed272ae8db08);
$parcel$export(module.exports, "executeSQL", () => $d83a07cbe27ed7f3$export$71c177e77c592df2);
$parcel$export(module.exports, "runAppleScript", () => $ca034de50c750bbf$export$8982d27dc997624f);
$parcel$export(module.exports, "runPowerShellScript", () => $d472c30fd9053885$export$fc36b0024b60e761);
$parcel$export(module.exports, "showFailureToast", () => $6c9bb2e572dea89d$export$80e5033e369189f3);
$parcel$export(module.exports, "withCache", () => $20660adb77b18d0d$export$33b32b3abf8170f0);
/// <reference types="node" />




function $4bb6dbab781b846e$export$722debc0e56fea39(value) {
    const ref = (0, $8zHUo$react.useRef)(value);
    const signalRef = (0, $8zHUo$react.useRef)(0);
    if (!(0, $8zHUo$dequallite.dequal)(value, ref.current)) {
        ref.current = value;
        signalRef.current += 1;
    }
    // eslint-disable-next-line react-hooks/exhaustive-deps
    return (0, $8zHUo$react.useMemo)(()=>ref.current, [
        signalRef.current
    ]);
}



function $07a180af23fbf38b$export$d4b699e2c1148419(value) {
    const ref = (0, $8zHUo$react.useRef)(value);
    ref.current = value;
    return ref;
}





function $6c9bb2e572dea89d$export$80e5033e369189f3(error, options) {
    const message = error instanceof Error ? error.message : String(error);
    return (0, $8zHUo$raycastapi.showToast)({
        style: (0, $8zHUo$raycastapi.Toast).Style.Failure,
        title: options?.title ?? "Something went wrong",
        message: options?.message ?? message,
        primaryAction: options?.primaryAction ?? $6c9bb2e572dea89d$var$handleErrorToastAction(error),
        secondaryAction: options?.primaryAction ? $6c9bb2e572dea89d$var$handleErrorToastAction(error) : undefined
    });
}
const $6c9bb2e572dea89d$var$handleErrorToastAction = (error)=>{
    let privateExtension = true;
    let title = "[Extension Name]...";
    let extensionURL = "";
    try {
        const packageJSON = JSON.parse($8zHUo$nodefs.readFileSync($8zHUo$nodepath.join((0, $8zHUo$raycastapi.environment).assetsPath, "..", "package.json"), "utf8"));
        title = `[${packageJSON.title}]...`;
        extensionURL = `https://raycast.com/${packageJSON.owner || packageJSON.author}/${packageJSON.name}`;
        if (!packageJSON.owner || packageJSON.access === "public") privateExtension = false;
    } catch (err) {
    // no-op
    }
    // if it's a private extension, we can't construct the URL to report the error
    // so we fallback to copying the error to the clipboard
    const fallback = (0, $8zHUo$raycastapi.environment).isDevelopment || privateExtension;
    const stack = error instanceof Error ? error?.stack || error?.message || "" : String(error);
    return {
        title: fallback ? "Copy Logs" : "Report Error",
        onAction (toast) {
            toast.hide();
            if (fallback) (0, $8zHUo$raycastapi.Clipboard).copy(stack);
            else (0, $8zHUo$raycastapi.open)(`https://github.com/raycast/extensions/issues/new?&labels=extension%2Cbug&template=extension_bug_report.yml&title=${encodeURIComponent(title)}&extension-url=${encodeURI(extensionURL)}&description=${encodeURIComponent(`#### Error:
\`\`\`
${stack}
\`\`\`
`)}`);
        }
    };
};


function $1f5338676d90e7a6$export$dd6b79aaabe7bc37(fn, args, options) {
    const lastCallId = (0, $8zHUo$react.useRef)(0);
    const [state, set] = (0, $8zHUo$react.useState)({
        isLoading: true
    });
    const fnRef = (0, $07a180af23fbf38b$export$d4b699e2c1148419)(fn);
    const latestAbortable = (0, $07a180af23fbf38b$export$d4b699e2c1148419)(options?.abortable);
    const latestArgs = (0, $07a180af23fbf38b$export$d4b699e2c1148419)(args || []);
    const latestOnError = (0, $07a180af23fbf38b$export$d4b699e2c1148419)(options?.onError);
    const latestOnData = (0, $07a180af23fbf38b$export$d4b699e2c1148419)(options?.onData);
    const latestOnWillExecute = (0, $07a180af23fbf38b$export$d4b699e2c1148419)(options?.onWillExecute);
    const latestFailureToast = (0, $07a180af23fbf38b$export$d4b699e2c1148419)(options?.failureToastOptions);
    const latestValue = (0, $07a180af23fbf38b$export$d4b699e2c1148419)(state.data);
    const latestCallback = (0, $8zHUo$react.useRef)(null);
    const paginationArgsRef = (0, $8zHUo$react.useRef)({
        page: 0
    });
    const usePaginationRef = (0, $8zHUo$react.useRef)(false);
    const hasMoreRef = (0, $8zHUo$react.useRef)(true);
    const pageSizeRef = (0, $8zHUo$react.useRef)(50);
    const abort = (0, $8zHUo$react.useCallback)(()=>{
        if (latestAbortable.current) {
            latestAbortable.current.current?.abort();
            latestAbortable.current.current = new AbortController();
        }
        return ++lastCallId.current;
    }, [
        latestAbortable
    ]);
    const callback = (0, $8zHUo$react.useCallback)((...args)=>{
        const callId = abort();
        latestOnWillExecute.current?.(args);
        set((prevState)=>({
                ...prevState,
                isLoading: true
            }));
        const promiseOrPaginatedPromise = $1f5338676d90e7a6$var$bindPromiseIfNeeded(fnRef.current)(...args);
        function handleError(error) {
            if (error.name == "AbortError") return error;
            if (callId === lastCallId.current) {
                // handle errors
                if (latestOnError.current) latestOnError.current(error);
                else if ((0, $8zHUo$raycastapi.environment).launchType !== (0, $8zHUo$raycastapi.LaunchType).Background) (0, $6c9bb2e572dea89d$export$80e5033e369189f3)(error, {
                    title: "Failed to fetch latest data",
                    primaryAction: {
                        title: "Retry",
                        onAction (toast) {
                            toast.hide();
                            latestCallback.current?.(...latestArgs.current || []);
                        }
                    },
                    ...latestFailureToast.current
                });
                set({
                    error: error,
                    isLoading: false
                });
            }
            return error;
        }
        if (typeof promiseOrPaginatedPromise === "function") {
            usePaginationRef.current = true;
            return promiseOrPaginatedPromise(paginationArgsRef.current).then(// @ts-expect-error too complicated for TS
            ({ data: data, hasMore: hasMore, cursor: cursor })=>{
                if (callId === lastCallId.current) {
                    if (paginationArgsRef.current) {
                        paginationArgsRef.current.cursor = cursor;
                        paginationArgsRef.current.lastItem = data?.[data.length - 1];
                    }
                    if (latestOnData.current) latestOnData.current(data, paginationArgsRef.current);
                    if (hasMore) pageSizeRef.current = data.length;
                    hasMoreRef.current = hasMore;
                    set((previousData)=>{
                        if (paginationArgsRef.current.page === 0) return {
                            data: data,
                            isLoading: false
                        };
                        // @ts-expect-error we know it's an array here
                        return {
                            data: (previousData.data || [])?.concat(data),
                            isLoading: false
                        };
                    });
                }
                return data;
            }, (error)=>{
                hasMoreRef.current = false;
                return handleError(error);
            });
        }
        usePaginationRef.current = false;
        return promiseOrPaginatedPromise.then((data)=>{
            if (callId === lastCallId.current) {
                if (latestOnData.current) latestOnData.current(data);
                set({
                    data: data,
                    isLoading: false
                });
            }
            return data;
        }, handleError);
    }, [
        latestOnData,
        latestOnError,
        latestArgs,
        fnRef,
        set,
        latestCallback,
        latestOnWillExecute,
        paginationArgsRef,
        latestFailureToast,
        abort
    ]);
    latestCallback.current = callback;
    const revalidate = (0, $8zHUo$react.useCallback)(()=>{
        // reset the pagination
        paginationArgsRef.current = {
            page: 0
        };
        const args = latestArgs.current || [];
        return callback(...args);
    }, [
        callback,
        latestArgs
    ]);
    const mutate = (0, $8zHUo$react.useCallback)(async (asyncUpdate, options)=>{
        let dataBeforeOptimisticUpdate;
        try {
            if (options?.optimisticUpdate) {
                // cancel the in-flight request to make sure it won't overwrite the optimistic update
                abort();
                if (typeof options?.rollbackOnError !== "function" && options?.rollbackOnError !== false) // keep track of the data before the optimistic update,
                // but only if we need it (eg. only when we want to automatically rollback after)
                dataBeforeOptimisticUpdate = structuredClone(latestValue.current?.value);
                const update = options.optimisticUpdate;
                set((prevState)=>({
                        ...prevState,
                        data: update(prevState.data)
                    }));
            }
            return await asyncUpdate;
        } catch (err) {
            if (typeof options?.rollbackOnError === "function") {
                const update = options.rollbackOnError;
                set((prevState)=>({
                        ...prevState,
                        data: update(prevState.data)
                    }));
            } else if (options?.optimisticUpdate && options?.rollbackOnError !== false) set((prevState)=>({
                    ...prevState,
                    data: dataBeforeOptimisticUpdate
                }));
            throw err;
        } finally{
            if (options?.shouldRevalidateAfter !== false) {
                if ((0, $8zHUo$raycastapi.environment).launchType === (0, $8zHUo$raycastapi.LaunchType).Background || (0, $8zHUo$raycastapi.environment).commandMode === "menu-bar") // when in the background or in a menu bar, we are going to await the revalidation
                // to make sure we get the right data at the end of the mutation
                await revalidate();
                else revalidate();
            }
        }
    }, [
        revalidate,
        latestValue,
        set,
        abort
    ]);
    const onLoadMore = (0, $8zHUo$react.useCallback)(()=>{
        paginationArgsRef.current.page += 1;
        const args = latestArgs.current || [];
        callback(...args);
    }, [
        paginationArgsRef,
        latestArgs,
        callback
    ]);
    // revalidate when the args change
    (0, $8zHUo$react.useEffect)(()=>{
        // reset the pagination
        paginationArgsRef.current = {
            page: 0
        };
        if (options?.execute !== false) callback(...args || []);
        else // cancel the previous request if we don't want to execute anymore
        abort();
    // eslint-disable-next-line react-hooks/exhaustive-deps
    }, [
        (0, $4bb6dbab781b846e$export$722debc0e56fea39)([
            args,
            options?.execute,
            callback
        ]),
        latestAbortable,
        paginationArgsRef
    ]);
    // abort request when unmounting
    (0, $8zHUo$react.useEffect)(()=>{
        return ()=>{
            abort();
        };
    }, [
        abort
    ]);
    // we only want to show the loading indicator if the promise is executing
    const isLoading = options?.execute !== false ? state.isLoading : false;
    // @ts-expect-error loading is has some fixed value in the enum which
    const stateWithLoadingFixed = {
        ...state,
        isLoading: isLoading
    };
    const pagination = usePaginationRef.current ? {
        pageSize: pageSizeRef.current,
        hasMore: hasMoreRef.current,
        onLoadMore: onLoadMore
    } : undefined;
    return {
        ...stateWithLoadingFixed,
        revalidate: revalidate,
        mutate: mutate,
        pagination: pagination
    };
}
/** Bind the fn if it's a Promise method */ function $1f5338676d90e7a6$var$bindPromiseIfNeeded(fn) {
    if (fn === Promise.all) // @ts-expect-error this is fine
    return fn.bind(Promise);
    if (fn === Promise.race) // @ts-expect-error this is fine
    return fn.bind(Promise);
    if (fn === Promise.resolve) // @ts-expect-error this is fine
    return fn.bind(Promise);
    if (fn === Promise.reject) // @ts-expect-error this is fine
    return fn.bind(Promise);
    return fn;
}






/* eslint-disable @typescript-eslint/ban-ts-comment */ /* eslint-disable @typescript-eslint/no-this-alias */ /* eslint-disable @typescript-eslint/no-explicit-any */ /** Check if the given function is a native function */ function $bb4e2b9279149d93$var$isNativeFunction(f) {
    if (typeof f !== "function") return false;
    const exp = /^function\s+\w*\s*\(\s*\)\s*{\s+\[native code\]\s+}$/i;
    return exp.exec(Function.prototype.toString.call(f)) !== null;
}
function $bb4e2b9279149d93$var$hashReplacer(value) {
    if (value instanceof URLSearchParams) return value.toString();
    return value;
}
function $bb4e2b9279149d93$export$fe386877a696ae78(writeTo, context = []) {
    function write(str) {
        if ("update" in writeTo) return writeTo.update(str, "utf8");
        else return writeTo.write(str);
    }
    return {
        dispatch: function(value) {
            value = $bb4e2b9279149d93$var$hashReplacer(value);
            const type = typeof value;
            if (value === null) this["_null"]();
            else // @ts-ignore
            this["_" + type](value);
        },
        _object: function(object) {
            const pattern = /\[object (.*)\]/i;
            const objString = Object.prototype.toString.call(object);
            let objType = pattern.exec(objString)?.[1] ?? "unknown:[" + objString + "]";
            objType = objType.toLowerCase();
            let objectNumber = null;
            if ((objectNumber = context.indexOf(object)) >= 0) {
                this.dispatch("[CIRCULAR:" + objectNumber + "]");
                return;
            } else context.push(object);
            if (Buffer.isBuffer(object)) {
                write("buffer:");
                return write(object.toString("utf8"));
            }
            if (objType !== "object" && objType !== "function" && objType !== "asyncfunction") {
                // @ts-ignore
                if (this["_" + objType]) // @ts-ignore
                this["_" + objType](object);
                else throw new Error('Unknown object type "' + objType + '"');
            } else {
                let keys = Object.keys(object);
                keys = keys.sort();
                // Make sure to incorporate special properties, so
                // Types with different prototypes will produce
                // a different hash and objects derived from
                // different functions (`new Foo`, `new Bar`) will
                // produce different hashes.
                // We never do this for native functions since some
                // seem to break because of that.
                if (!$bb4e2b9279149d93$var$isNativeFunction(object)) keys.splice(0, 0, "prototype", "__proto__", "constructor");
                write("object:" + keys.length + ":");
                const self = this;
                return keys.forEach(function(key) {
                    self.dispatch(key);
                    write(":");
                    self.dispatch(object[key]);
                    write(",");
                });
            }
        },
        _array: function(arr, unordered) {
            unordered = typeof unordered !== "undefined" ? unordered : false; // default to options.unorderedArrays
            const self = this;
            write("array:" + arr.length + ":");
            if (!unordered || arr.length <= 1) {
                arr.forEach(function(entry) {
                    self.dispatch(entry);
                });
                return;
            }
            // the unordered case is a little more complicated:
            // since there is no canonical ordering on objects,
            // i.e. {a:1} < {a:2} and {a:1} > {a:2} are both false,
            // we first serialize each entry using a PassThrough stream
            // before sorting.
            // also: we can’t use the same context array for all entries
            // since the order of hashing should *not* matter. instead,
            // we keep track of the additions to a copy of the context array
            // and add all of them to the global context array when we’re done
            let contextAdditions = [];
            const entries = arr.map(function(entry) {
                const strm = $bb4e2b9279149d93$var$PassThrough();
                const localContext = context.slice(); // make copy
                const hasher = $bb4e2b9279149d93$export$fe386877a696ae78(strm, localContext);
                hasher.dispatch(entry);
                // take only what was added to localContext and append it to contextAdditions
                contextAdditions = contextAdditions.concat(localContext.slice(context.length));
                return strm.read().toString();
            });
            context = context.concat(contextAdditions);
            entries.sort();
            this._array(entries, false);
        },
        _date: function(date) {
            write("date:" + date.toJSON());
        },
        _symbol: function(sym) {
            write("symbol:" + sym.toString());
        },
        _error: function(err) {
            write("error:" + err.toString());
        },
        _boolean: function(bool) {
            write("bool:" + bool.toString());
        },
        _string: function(string) {
            write("string:" + string.length + ":");
            write(string.toString());
        },
        _function: function(fn) {
            write("fn:");
            if ($bb4e2b9279149d93$var$isNativeFunction(fn)) this.dispatch("[native]");
            else this.dispatch(fn.toString());
            // Make sure we can still distinguish native functions
            // by their name, otherwise String and Function will
            // have the same hash
            this.dispatch("function-name:" + String(fn.name));
            this._object(fn);
        },
        _number: function(number) {
            write("number:" + number.toString());
        },
        _xml: function(xml) {
            write("xml:" + xml.toString());
        },
        _null: function() {
            write("Null");
        },
        _undefined: function() {
            write("Undefined");
        },
        _regexp: function(regex) {
            write("regex:" + regex.toString());
        },
        _uint8array: function(arr) {
            write("uint8array:");
            this.dispatch(Array.prototype.slice.call(arr));
        },
        _uint8clampedarray: function(arr) {
            write("uint8clampedarray:");
            this.dispatch(Array.prototype.slice.call(arr));
        },
        _int8array: function(arr) {
            write("int8array:");
            this.dispatch(Array.prototype.slice.call(arr));
        },
        _uint16array: function(arr) {
            write("uint16array:");
            this.dispatch(Array.prototype.slice.call(arr));
        },
        _int16array: function(arr) {
            write("int16array:");
            this.dispatch(Array.prototype.slice.call(arr));
        },
        _uint32array: function(arr) {
            write("uint32array:");
            this.dispatch(Array.prototype.slice.call(arr));
        },
        _int32array: function(arr) {
            write("int32array:");
            this.dispatch(Array.prototype.slice.call(arr));
        },
        _float32array: function(arr) {
            write("float32array:");
            this.dispatch(Array.prototype.slice.call(arr));
        },
        _float64array: function(arr) {
            write("float64array:");
            this.dispatch(Array.prototype.slice.call(arr));
        },
        _arraybuffer: function(arr) {
            write("arraybuffer:");
            this.dispatch(new Uint8Array(arr));
        },
        _url: function(url) {
            write("url:" + url.toString());
        },
        _map: function(map) {
            write("map:");
            const arr = Array.from(map);
            this._array(arr, true);
        },
        _set: function(set) {
            write("set:");
            const arr = Array.from(set);
            this._array(arr, true);
        },
        _file: function(file) {
            write("file:");
            this.dispatch([
                file.name,
                file.size,
                file.type,
                file.lastModified
            ]);
        },
        _blob: function() {
            throw Error('Hashing Blob objects is currently not supported\n(see https://github.com/puleos/object-hash/issues/26)\nUse "options.replacer" or "options.ignoreUnknown"\n');
        },
        _domwindow: function() {
            write("domwindow");
        },
        _bigint: function(number) {
            write("bigint:" + number.toString());
        },
        /* Node.js standard native objects */ _process: function() {
            write("process");
        },
        _timer: function() {
            write("timer");
        },
        _pipe: function() {
            write("pipe");
        },
        _tcp: function() {
            write("tcp");
        },
        _udp: function() {
            write("udp");
        },
        _tty: function() {
            write("tty");
        },
        _statwatcher: function() {
            write("statwatcher");
        },
        _securecontext: function() {
            write("securecontext");
        },
        _connection: function() {
            write("connection");
        },
        _zlib: function() {
            write("zlib");
        },
        _context: function() {
            write("context");
        },
        _nodescript: function() {
            write("nodescript");
        },
        _httpparser: function() {
            write("httpparser");
        },
        _dataview: function() {
            write("dataview");
        },
        _signal: function() {
            write("signal");
        },
        _fsevent: function() {
            write("fsevent");
        },
        _tlswrap: function() {
            write("tlswrap");
        }
    };
}
// Mini-implementation of stream.PassThrough
// We are far from having need for the full implementation, and we can
// make assumptions like "many writes, then only one final read"
// and we can ignore encoding specifics
function $bb4e2b9279149d93$var$PassThrough() {
    return {
        buf: "",
        write: function(b) {
            this.buf += b;
        },
        end: function(b) {
            this.buf += b;
        },
        read: function() {
            return this.buf;
        }
    };
}


function $dfecd32049fa58e9$export$b644b65666fe0c18(key, _value) {
    const value = this[key];
    if (value instanceof Date) return `__raycast_cached_date__${value.toISOString()}`;
    if (Buffer.isBuffer(value)) return `__raycast_cached_buffer__${value.toString("base64")}`;
    return _value;
}
function $dfecd32049fa58e9$export$63698c10df99509c(_key, value) {
    if (typeof value === "string" && value.startsWith("__raycast_cached_date__")) return new Date(value.replace("__raycast_cached_date__", ""));
    if (typeof value === "string" && value.startsWith("__raycast_cached_buffer__")) return Buffer.from(value.replace("__raycast_cached_buffer__", ""), "base64");
    return value;
}
function $dfecd32049fa58e9$export$d6af199866bfb566(object) {
    const hashingStream = (0, ($parcel$interopDefault($8zHUo$nodecrypto))).createHash("sha1");
    const hasher = (0, $bb4e2b9279149d93$export$fe386877a696ae78)(hashingStream);
    hasher.dispatch(object);
    return hashingStream.digest("hex");
}


const $4edf56917e12e612$var$rootCache = /* #__PURE__ */ Symbol("cache without namespace");
const $4edf56917e12e612$var$cacheMap = /* #__PURE__ */ new Map();
function $4edf56917e12e612$export$14afb9e4c16377d3(key, initialState, config) {
    const cacheKey = config?.cacheNamespace || $4edf56917e12e612$var$rootCache;
    const cache = $4edf56917e12e612$var$cacheMap.get(cacheKey) || $4edf56917e12e612$var$cacheMap.set(cacheKey, new (0, $8zHUo$raycastapi.Cache)({
        namespace: config?.cacheNamespace
    })).get(cacheKey);
    if (!cache) throw new Error("Missing cache");
    const keyRef = (0, $07a180af23fbf38b$export$d4b699e2c1148419)(key);
    const initialValueRef = (0, $07a180af23fbf38b$export$d4b699e2c1148419)(initialState);
    const cachedState = (0, $8zHUo$react.useSyncExternalStore)(cache.subscribe, ()=>{
        try {
            return cache.get(keyRef.current);
        } catch (error) {
            console.error("Could not get Cache data:", error);
            return undefined;
        }
    });
    const state = (0, $8zHUo$react.useMemo)(()=>{
        if (typeof cachedState !== "undefined") {
            if (cachedState === "undefined") return undefined;
            try {
                return JSON.parse(cachedState, (0, $dfecd32049fa58e9$export$63698c10df99509c));
            } catch (err) {
                // the data got corrupted somehow
                console.warn("The cached data is corrupted", err);
                return initialValueRef.current;
            }
        } else return initialValueRef.current;
    }, [
        cachedState,
        initialValueRef
    ]);
    const stateRef = (0, $07a180af23fbf38b$export$d4b699e2c1148419)(state);
    const setStateAndCache = (0, $8zHUo$react.useCallback)((updater)=>{
        // @ts-expect-error TS struggles to infer the types as T could potentially be a function
        const newValue = typeof updater === "function" ? updater(stateRef.current) : updater;
        if (typeof newValue === "undefined") cache.set(keyRef.current, "undefined");
        else {
            const stringifiedValue = JSON.stringify(newValue, (0, $dfecd32049fa58e9$export$b644b65666fe0c18));
            cache.set(keyRef.current, stringifiedValue);
        }
        return newValue;
    }, [
        cache,
        keyRef,
        stateRef
    ]);
    return [
        state,
        setStateAndCache
    ];
}







// Symbol to differentiate an empty cache from `undefined`
const $a9b0b6f46ce12461$var$emptyCache = /* #__PURE__ */ Symbol();
function $a9b0b6f46ce12461$export$b15740c74e256244(fn, args, options) {
    /**
   * The hook generates a cache key from the promise it receives & its arguments.
   * Sometimes that's not enough to guarantee uniqueness, so hooks that build on top of `useCachedPromise` can
   * use an `internal_cacheKeySuffix` to help it.
   *
   * @remark For internal use only.
   */ const { initialData: initialData, keepPreviousData: keepPreviousData, internal_cacheKeySuffix: internal_cacheKeySuffix, ...usePromiseOptions } = options || {};
    const lastUpdateFrom = (0, $8zHUo$react.useRef)(null);
    const [cachedData, mutateCache] = (0, $4edf56917e12e612$export$14afb9e4c16377d3)((0, $dfecd32049fa58e9$export$d6af199866bfb566)(args || []) + internal_cacheKeySuffix, $a9b0b6f46ce12461$var$emptyCache, {
        cacheNamespace: (0, $dfecd32049fa58e9$export$d6af199866bfb566)(fn)
    });
    // Use a ref to store previous returned data. Use the inital data as its inital value from the cache.
    const laggyDataRef = (0, $8zHUo$react.useRef)(cachedData !== $a9b0b6f46ce12461$var$emptyCache ? cachedData : initialData);
    const paginationArgsRef = (0, $8zHUo$react.useRef)(undefined);
    const { mutate: _mutate, revalidate: revalidate, ...state } = (0, $1f5338676d90e7a6$export$dd6b79aaabe7bc37)(fn, args || [], {
        ...usePromiseOptions,
        onData (data, pagination) {
            paginationArgsRef.current = pagination;
            if (usePromiseOptions.onData) usePromiseOptions.onData(data, pagination);
            if (pagination && pagination.page > 0) // don't cache beyond the first page
            return;
            lastUpdateFrom.current = "promise";
            laggyDataRef.current = data;
            mutateCache(data);
        }
    });
    let returnedData;
    const pagination = state.pagination;
    // when paginating, only the first page gets cached, so we return the data we get from `usePromise`, because
    // it will be accumulated.
    if (paginationArgsRef.current && paginationArgsRef.current.page > 0 && state.data) returnedData = state.data;
    else if (lastUpdateFrom.current === "promise") returnedData = laggyDataRef.current;
    else if (keepPreviousData && cachedData !== $a9b0b6f46ce12461$var$emptyCache) {
        // if we want to keep the latest data, we pick the cache but only if it's not empty
        returnedData = cachedData;
        if (pagination) {
            pagination.hasMore = true;
            pagination.pageSize = cachedData.length;
        }
    } else if (keepPreviousData && cachedData === $a9b0b6f46ce12461$var$emptyCache) // if the cache is empty, we will return the previous data
    returnedData = laggyDataRef.current;
    else if (cachedData !== $a9b0b6f46ce12461$var$emptyCache) {
        returnedData = cachedData;
        if (pagination) {
            pagination.hasMore = true;
            pagination.pageSize = cachedData.length;
        }
    } else returnedData = initialData;
    const latestData = (0, $07a180af23fbf38b$export$d4b699e2c1148419)(returnedData);
    // we rewrite the mutate function to update the cache instead
    const mutate = (0, $8zHUo$react.useCallback)(async (asyncUpdate, options)=>{
        let dataBeforeOptimisticUpdate;
        try {
            if (options?.optimisticUpdate) {
                if (typeof options?.rollbackOnError !== "function" && options?.rollbackOnError !== false) // keep track of the data before the optimistic update,
                // but only if we need it (eg. only when we want to automatically rollback after)
                dataBeforeOptimisticUpdate = structuredClone(latestData.current);
                const data = options.optimisticUpdate(latestData.current);
                lastUpdateFrom.current = "cache";
                laggyDataRef.current = data;
                mutateCache(data);
            }
            return await _mutate(asyncUpdate, {
                shouldRevalidateAfter: options?.shouldRevalidateAfter
            });
        } catch (err) {
            if (typeof options?.rollbackOnError === "function") {
                const data = options.rollbackOnError(latestData.current);
                lastUpdateFrom.current = "cache";
                laggyDataRef.current = data;
                mutateCache(data);
            } else if (options?.optimisticUpdate && options?.rollbackOnError !== false) {
                lastUpdateFrom.current = "cache";
                // @ts-expect-error when undefined, it's expected
                laggyDataRef.current = dataBeforeOptimisticUpdate;
                // @ts-expect-error when undefined, it's expected
                mutateCache(dataBeforeOptimisticUpdate);
            }
            throw err;
        }
    }, [
        mutateCache,
        _mutate,
        latestData,
        laggyDataRef,
        lastUpdateFrom
    ]);
    (0, $8zHUo$react.useEffect)(()=>{
        if (cachedData !== $a9b0b6f46ce12461$var$emptyCache) {
            lastUpdateFrom.current = "cache";
            laggyDataRef.current = cachedData;
        }
    }, [
        cachedData
    ]);
    return {
        data: returnedData,
        isLoading: state.isLoading,
        error: state.error,
        mutate: paginationArgsRef.current && paginationArgsRef.current.page > 0 ? _mutate : mutate,
        pagination: pagination,
        revalidate: revalidate
    };
}





function $5c00fc5faeba62a7$export$3427e80ee71d60ba(contentTypeHeader) {
    if (contentTypeHeader) {
        const mediaType = $5c00fc5faeba62a7$var$parseContentType(contentTypeHeader);
        if (!mediaType) return false;
        if (mediaType.subtype === "json") return true;
        if (mediaType.suffix === "json") return true;
        if (mediaType.suffix && /\bjson\b/i.test(mediaType.suffix)) return true;
        if (mediaType.subtype && /\bjson\b/i.test(mediaType.subtype)) return true;
    }
    return false;
}
/**
 * RegExp to match type in RFC 6838 with an optional trailing `;` because some Apple APIs returns one...
 *
 * type-name = restricted-name
 * subtype-name = restricted-name
 * restricted-name = restricted-name-first *126restricted-name-chars
 * restricted-name-first  = ALPHA / DIGIT
 * restricted-name-chars  = ALPHA / DIGIT / "!" / "#" /
 *                          "$" / "&" / "-" / "^" / "_"
 * restricted-name-chars =/ "." ; Characters before first dot always
 *                              ; specify a facet name
 * restricted-name-chars =/ "+" ; Characters after last plus always
 *                              ; specify a structured syntax suffix
 * ALPHA =  %x41-5A / %x61-7A   ; A-Z / a-z
 * DIGIT =  %x30-39             ; 0-9
 */ const $5c00fc5faeba62a7$var$MEDIA_TYPE_REGEXP = /^([A-Za-z0-9][A-Za-z0-9!#$&^_-]{0,126})\/([A-Za-z0-9][A-Za-z0-9!#$&^_.+-]{0,126});?$/;
function $5c00fc5faeba62a7$var$parseContentType(header) {
    const headerDelimitationindex = header.indexOf(";");
    const contentType = headerDelimitationindex !== -1 ? header.slice(0, headerDelimitationindex).trim() : header.trim();
    const match = $5c00fc5faeba62a7$var$MEDIA_TYPE_REGEXP.exec(contentType.toLowerCase().toLowerCase());
    if (!match) return;
    const type = match[1];
    let subtype = match[2];
    let suffix;
    // suffix after last +
    const index = subtype.lastIndexOf("+");
    if (index !== -1) {
        suffix = subtype.substring(index + 1);
        subtype = subtype.substring(0, index);
    }
    return {
        type: type,
        subtype: subtype,
        suffix: suffix
    };
}



async function $d1b00242b8395b80$var$defaultParsing(response) {
    if (!response.ok) throw new Error(response.statusText);
    const contentTypeHeader = response.headers.get("content-type");
    if (contentTypeHeader && (0, $5c00fc5faeba62a7$export$3427e80ee71d60ba)(contentTypeHeader)) return await response.json();
    return await response.text();
}
function $d1b00242b8395b80$var$defaultMapping(result) {
    return {
        data: result,
        hasMore: false
    };
}
function $d1b00242b8395b80$export$d852f5f778460fa4(url, options) {
    const { parseResponse: parseResponse, mapResult: mapResult, initialData: initialData, execute: execute, keepPreviousData: keepPreviousData, onError: onError, onData: onData, onWillExecute: onWillExecute, failureToastOptions: failureToastOptions, ...fetchOptions } = options || {};
    const useCachedPromiseOptions = {
        initialData: initialData,
        execute: execute,
        keepPreviousData: keepPreviousData,
        onError: onError,
        onData: onData,
        onWillExecute: onWillExecute,
        failureToastOptions: failureToastOptions
    };
    const parseResponseRef = (0, $07a180af23fbf38b$export$d4b699e2c1148419)(parseResponse || $d1b00242b8395b80$var$defaultParsing);
    const mapResultRef = (0, $07a180af23fbf38b$export$d4b699e2c1148419)(mapResult || $d1b00242b8395b80$var$defaultMapping);
    const urlRef = (0, $8zHUo$react.useRef)(null);
    const firstPageUrlRef = (0, $8zHUo$react.useRef)(null);
    const firstPageUrl = typeof url === "function" ? url({
        page: 0
    }) : undefined;
    /**
   * When paginating, `url` is a `PaginatedRequestInfo`, so we only want to update the ref when the `firstPageUrl` changes.
   * When not paginating, `url` is a `RequestInfo`, so we want to update the ref whenever `url` changes.
   */ if (!urlRef.current || typeof firstPageUrlRef.current === "undefined" || firstPageUrlRef.current !== firstPageUrl) urlRef.current = url;
    firstPageUrlRef.current = firstPageUrl;
    const abortable = (0, $8zHUo$react.useRef)(null);
    const paginatedFn = (0, $8zHUo$react.useCallback)((url, options)=>async (pagination)=>{
            const res = await fetch(url(pagination), {
                signal: abortable.current?.signal,
                ...options
            });
            const parsed = await parseResponseRef.current(res);
            return mapResultRef.current?.(parsed);
        }, [
        parseResponseRef,
        mapResultRef
    ]);
    const fn = (0, $8zHUo$react.useCallback)(async (url, options)=>{
        const res = await fetch(url, {
            signal: abortable.current?.signal,
            ...options
        });
        const parsed = await parseResponseRef.current(res);
        const mapped = mapResultRef.current(parsed);
        return mapped?.data;
    }, [
        parseResponseRef,
        mapResultRef
    ]);
    const promise = (0, $8zHUo$react.useMemo)(()=>{
        if (firstPageUrlRef.current) return paginatedFn;
        return fn;
    }, [
        firstPageUrlRef,
        fn,
        paginatedFn
    ]);
    // @ts-expect-error lastItem can't be inferred properly
    return (0, $a9b0b6f46ce12461$export$b15740c74e256244)(promise, [
        urlRef.current,
        fetchOptions
    ], {
        ...useCachedPromiseOptions,
        internal_cacheKeySuffix: firstPageUrlRef.current + (0, $dfecd32049fa58e9$export$d6af199866bfb566)(mapResultRef.current) + (0, $dfecd32049fa58e9$export$d6af199866bfb566)(parseResponseRef.current),
        abortable: abortable
    });
}


/*
 * Inspired by Execa
 */ 






/* eslint-disable @typescript-eslint/ban-ts-comment */ /* eslint-disable @typescript-eslint/no-explicit-any */ // Note: since nyc uses this module to output coverage, any lines
// that are in the direct sync flow of nyc's outputCoverage are
// ignored, since we can never get coverage for them.
// grab a reference to node's real process object right away
const $e4f062293a232d5d$var$processOk = (process1)=>!!process1 && typeof process1 === "object" && typeof process1.removeListener === "function" && typeof process1.emit === "function" && typeof process1.reallyExit === "function" && typeof process1.listeners === "function" && typeof process1.kill === "function" && typeof process1.pid === "number" && typeof process1.on === "function";
const $e4f062293a232d5d$var$kExitEmitter = /* #__PURE__ */ Symbol.for("signal-exit emitter");
// teeny special purpose ee
class $e4f062293a232d5d$var$Emitter {
    constructor(){
        this.emitted = {
            afterExit: false,
            exit: false
        };
        this.listeners = {
            afterExit: [],
            exit: []
        };
        this.count = 0;
        this.id = Math.random();
        // @ts-ignore
        if ($parcel$global[$e4f062293a232d5d$var$kExitEmitter]) // @ts-ignore
        return $parcel$global[$e4f062293a232d5d$var$kExitEmitter];
        Object.defineProperty($parcel$global, $e4f062293a232d5d$var$kExitEmitter, {
            value: this,
            writable: false,
            enumerable: false,
            configurable: false
        });
    }
    on(ev, fn) {
        // @ts-ignore
        this.listeners[ev].push(fn);
    }
    removeListener(ev, fn) {
        // @ts-ignore
        const list = this.listeners[ev];
        const i = list.indexOf(fn);
        /* c8 ignore start */ if (i === -1) return;
        /* c8 ignore stop */ if (i === 0 && list.length === 1) list.length = 0;
        else list.splice(i, 1);
    }
    emit(ev, code, signal) {
        // @ts-ignore
        if (this.emitted[ev]) return false;
        // @ts-ignore
        this.emitted[ev] = true;
        let ret = false;
        // @ts-ignore
        for (const fn of this.listeners[ev])ret = fn(code, signal) === true || ret;
        if (ev === "exit") ret = this.emit("afterExit", code, signal) || ret;
        return ret;
    }
}
class $e4f062293a232d5d$var$SignalExitFallback {
    onExit() {
        return ()=>{};
    }
    load() {}
    unload() {}
}
class $e4f062293a232d5d$var$SignalExit {
    // "SIGHUP" throws an `ENOSYS` error on Windows,
    // so use a supported signal instead
    /* c8 ignore start */ // @ts-ignore
    #hupSig;
    /* c8 ignore stop */ #emitter;
    #process;
    #originalProcessEmit;
    #originalProcessReallyExit;
    #sigListeners;
    #loaded;
    #signals;
    constructor(process1){
        this.#hupSig = process.platform === "win32" ? "SIGINT" : "SIGHUP";
        this.#emitter = new $e4f062293a232d5d$var$Emitter();
        this.#sigListeners = {};
        this.#loaded = false;
        this.#signals = [];
        /**
     * This is not the set of all possible signals.
     *
     * It IS, however, the set of all signals that trigger
     * an exit on either Linux or BSD systems.  Linux is a
     * superset of the signal names supported on BSD, and
     * the unknown signals just fail to register, so we can
     * catch that easily enough.
     *
     * Windows signals are a different set, since there are
     * signals that terminate Windows processes, but don't
     * terminate (or don't even exist) on Posix systems.
     *
     * Don't bother with SIGKILL.  It's uncatchable, which
     * means that we can't fire any callbacks anyway.
     *
     * If a user does happen to register a handler on a non-
     * fatal signal like SIGWINCH or something, and then
     * exit, it'll end up firing `process.emit('exit')`, so
     * the handler will be fired anyway.
     *
     * SIGBUS, SIGFPE, SIGSEGV and SIGILL, when not raised
     * artificially, inherently leave the process in a
     * state from which it is not safe to try and enter JS
     * listeners.
     */ this.#signals.push("SIGHUP", "SIGINT", "SIGTERM");
        if (globalThis.process.platform !== "win32") this.#signals.push("SIGALRM", "SIGABRT", "SIGVTALRM", "SIGXCPU", "SIGXFSZ", "SIGUSR2", "SIGTRAP", "SIGSYS", "SIGQUIT", "SIGIOT");
        if (globalThis.process.platform === "linux") this.#signals.push("SIGIO", "SIGPOLL", "SIGPWR", "SIGSTKFLT");
        this.#process = process1;
        // { <signal>: <listener fn>, ... }
        this.#sigListeners = {};
        for (const sig of this.#signals)// @ts-ignore
        this.#sigListeners[sig] = ()=>{
            // If there are no other listeners, an exit is coming!
            // Simplest way: remove us and then re-send the signal.
            // We know that this will kill the process, so we can
            // safely emit now.
            const listeners = this.#process.listeners(sig);
            let { count: count } = this.#emitter;
            // This is a workaround for the fact that signal-exit v3 and signal
            // exit v4 are not aware of each other, and each will attempt to let
            // the other handle it, so neither of them do. To correct this, we
            // detect if we're the only handler *except* for previous versions
            // of signal-exit, and increment by the count of listeners it has
            // created.
            /* c8 ignore start */ const p = process1;
            if (typeof p.__signal_exit_emitter__ === "object" && typeof p.__signal_exit_emitter__.count === "number") count += p.__signal_exit_emitter__.count;
            /* c8 ignore stop */ if (listeners.length === count) {
                this.unload();
                const ret = this.#emitter.emit("exit", null, sig);
                /* c8 ignore start */ const s = sig === "SIGHUP" ? this.#hupSig : sig;
                if (!ret) process1.kill(process1.pid, s);
            /* c8 ignore stop */ }
        };
        this.#originalProcessReallyExit = process1.reallyExit;
        this.#originalProcessEmit = process1.emit;
    }
    onExit(cb, opts) {
        /* c8 ignore start */ if (!$e4f062293a232d5d$var$processOk(this.#process)) return ()=>{};
        /* c8 ignore stop */ if (this.#loaded === false) this.load();
        const ev = opts?.alwaysLast ? "afterExit" : "exit";
        this.#emitter.on(ev, cb);
        return ()=>{
            this.#emitter.removeListener(ev, cb);
            if (this.#emitter.listeners["exit"].length === 0 && this.#emitter.listeners["afterExit"].length === 0) this.unload();
        };
    }
    load() {
        if (this.#loaded) return;
        this.#loaded = true;
        // This is the number of onSignalExit's that are in play.
        // It's important so that we can count the correct number of
        // listeners on signals, and don't wait for the other one to
        // handle it instead of us.
        this.#emitter.count += 1;
        for (const sig of this.#signals)try {
            // @ts-ignore
            const fn = this.#sigListeners[sig];
            if (fn) this.#process.on(sig, fn);
        } catch (_) {
        // no-op
        }
        this.#process.emit = (ev, ...a)=>{
            return this.#processEmit(ev, ...a);
        };
        this.#process.reallyExit = (code)=>{
            return this.#processReallyExit(code);
        };
    }
    unload() {
        if (!this.#loaded) return;
        this.#loaded = false;
        this.#signals.forEach((sig)=>{
            // @ts-ignore
            const listener = this.#sigListeners[sig];
            /* c8 ignore start */ if (!listener) throw new Error("Listener not defined for signal: " + sig);
            /* c8 ignore stop */ try {
                this.#process.removeListener(sig, listener);
            /* c8 ignore start */ } catch (_) {
            // no-op
            }
        /* c8 ignore stop */ });
        this.#process.emit = this.#originalProcessEmit;
        this.#process.reallyExit = this.#originalProcessReallyExit;
        this.#emitter.count -= 1;
    }
    #processReallyExit(code) {
        /* c8 ignore start */ if (!$e4f062293a232d5d$var$processOk(this.#process)) return 0;
        this.#process.exitCode = code || 0;
        /* c8 ignore stop */ this.#emitter.emit("exit", this.#process.exitCode, null);
        return this.#originalProcessReallyExit.call(this.#process, this.#process.exitCode);
    }
    #processEmit(ev, ...args) {
        const og = this.#originalProcessEmit;
        if (ev === "exit" && $e4f062293a232d5d$var$processOk(this.#process)) {
            if (typeof args[0] === "number") this.#process.exitCode = args[0];
            /* c8 ignore start */ const ret = og.call(this.#process, ev, ...args);
            /* c8 ignore start */ this.#emitter.emit("exit", this.#process.exitCode, null);
            /* c8 ignore stop */ return ret;
        } else return og.call(this.#process, ev, ...args);
    }
}
let $e4f062293a232d5d$var$signalExit = null;
const $e4f062293a232d5d$export$47a57ed64c292d4f = (cb, opts)=>{
    if (!$e4f062293a232d5d$var$signalExit) $e4f062293a232d5d$var$signalExit = $e4f062293a232d5d$var$processOk(process) ? new $e4f062293a232d5d$var$SignalExit(process) : new $e4f062293a232d5d$var$SignalExitFallback();
    return $e4f062293a232d5d$var$signalExit.onExit(cb, opts);
};


function $abcdf0eb4757394f$export$6e3a9b5342d42997(spawned, { timeout: timeout } = {}) {
    const spawnedPromise = new Promise((resolve, reject)=>{
        spawned.on("exit", (exitCode, signal)=>{
            resolve({
                exitCode: exitCode,
                signal: signal,
                timedOut: false
            });
        });
        spawned.on("error", (error)=>{
            reject(error);
        });
        if (spawned.stdin) spawned.stdin.on("error", (error)=>{
            reject(error);
        });
    });
    const removeExitHandler = (0, $e4f062293a232d5d$export$47a57ed64c292d4f)(()=>{
        spawned.kill();
    });
    if (timeout === 0 || timeout === undefined) return spawnedPromise.finally(()=>removeExitHandler());
    let timeoutId;
    const timeoutPromise = new Promise((_resolve, reject)=>{
        timeoutId = setTimeout(()=>{
            spawned.kill("SIGTERM");
            reject(Object.assign(new Error("Timed out"), {
                timedOut: true,
                signal: "SIGTERM"
            }));
        }, timeout);
    });
    const safeSpawnedPromise = spawnedPromise.finally(()=>{
        clearTimeout(timeoutId);
    });
    return Promise.race([
        timeoutPromise,
        safeSpawnedPromise
    ]).finally(()=>removeExitHandler());
}
class $abcdf0eb4757394f$var$MaxBufferError extends Error {
    constructor(){
        super("The output is too big");
        this.name = "MaxBufferError";
    }
}
function $abcdf0eb4757394f$var$bufferStream(options) {
    const { encoding: encoding } = options;
    const isBuffer = encoding === "buffer";
    // @ts-expect-error missing the methods we are adding below
    const stream = new (0, ($parcel$interopDefault($8zHUo$nodestream))).PassThrough({
        objectMode: false
    });
    if (encoding && encoding !== "buffer") stream.setEncoding(encoding);
    let length = 0;
    const chunks = [];
    stream.on("data", (chunk)=>{
        chunks.push(chunk);
        length += chunk.length;
    });
    stream.getBufferedValue = ()=>{
        return isBuffer ? Buffer.concat(chunks, length) : chunks.join("");
    };
    stream.getBufferedLength = ()=>length;
    return stream;
}
async function $abcdf0eb4757394f$var$getStream(inputStream, options) {
    const stream = $abcdf0eb4757394f$var$bufferStream(options);
    await new Promise((resolve, reject)=>{
        const rejectPromise = (error)=>{
            // Don't retrieve an oversized buffer.
            if (error && stream.getBufferedLength() <= (0, $8zHUo$nodebuffer.constants).MAX_LENGTH) error.bufferedData = stream.getBufferedValue();
            reject(error);
        };
        (async ()=>{
            try {
                await (0, $8zHUo$nodeutil.promisify)((0, ($parcel$interopDefault($8zHUo$nodestream))).pipeline)(inputStream, stream);
                resolve();
            } catch (error) {
                rejectPromise(error);
            }
        })();
        stream.on("data", ()=>{
            // 80mb
            if (stream.getBufferedLength() > 80000000) rejectPromise(new $abcdf0eb4757394f$var$MaxBufferError());
        });
    });
    return stream.getBufferedValue();
}
// On failure, `result.stdout|stderr` should contain the currently buffered stream
async function $abcdf0eb4757394f$var$getBufferedData(stream, streamPromise) {
    stream.destroy();
    try {
        return await streamPromise;
    } catch (error) {
        return error.bufferedData;
    }
}
async function $abcdf0eb4757394f$export$67b768ac9e1c70fa({ stdout: stdout, stderr: stderr }, { encoding: encoding }, processDone) {
    const stdoutPromise = $abcdf0eb4757394f$var$getStream(stdout, {
        encoding: encoding
    });
    const stderrPromise = $abcdf0eb4757394f$var$getStream(stderr, {
        encoding: encoding
    });
    try {
        return await Promise.all([
            processDone,
            stdoutPromise,
            stderrPromise
        ]);
    } catch (error) {
        return Promise.all([
            {
                error: error,
                exitCode: null,
                signal: error.signal,
                timedOut: error.timedOut || false
            },
            $abcdf0eb4757394f$var$getBufferedData(stdout, stdoutPromise),
            $abcdf0eb4757394f$var$getBufferedData(stderr, stderrPromise)
        ]);
    }
}
function $abcdf0eb4757394f$var$stripFinalNewline(input) {
    const LF = typeof input === "string" ? "\n" : "\n".charCodeAt(0);
    const CR = typeof input === "string" ? "\r" : "\r".charCodeAt(0);
    if (input[input.length - 1] === LF) // @ts-expect-error we are doing some nasty stuff here
    input = input.slice(0, -1);
    if (input[input.length - 1] === CR) // @ts-expect-error we are doing some nasty stuff here
    input = input.slice(0, -1);
    return input;
}
function $abcdf0eb4757394f$export$200978bbc0b73ca(options, value) {
    if (options.stripFinalNewline) return $abcdf0eb4757394f$var$stripFinalNewline(value);
    return value;
}
function $abcdf0eb4757394f$var$getErrorPrefix({ timedOut: timedOut, timeout: timeout, signal: signal, exitCode: exitCode }) {
    if (timedOut) return `timed out after ${timeout} milliseconds`;
    if (signal !== undefined && signal !== null) return `was killed with ${signal}`;
    if (exitCode !== undefined && exitCode !== null) return `failed with exit code ${exitCode}`;
    return "failed";
}
function $abcdf0eb4757394f$var$makeError({ stdout: stdout, stderr: stderr, error: error, signal: signal, exitCode: exitCode, command: command, timedOut: timedOut, options: options, parentError: parentError }) {
    const prefix = $abcdf0eb4757394f$var$getErrorPrefix({
        timedOut: timedOut,
        timeout: options?.timeout,
        signal: signal,
        exitCode: exitCode
    });
    const execaMessage = `Command ${prefix}: ${command}`;
    const shortMessage = error ? `${execaMessage}\n${error.message}` : execaMessage;
    const message = [
        shortMessage,
        stderr,
        stdout
    ].filter(Boolean).join("\n");
    if (error) // @ts-expect-error not on Error
    error.originalMessage = error.message;
    else error = parentError;
    error.message = message;
    // @ts-expect-error not on Error
    error.shortMessage = shortMessage;
    // @ts-expect-error not on Error
    error.command = command;
    // @ts-expect-error not on Error
    error.exitCode = exitCode;
    // @ts-expect-error not on Error
    error.signal = signal;
    // @ts-expect-error not on Error
    error.stdout = stdout;
    // @ts-expect-error not on Error
    error.stderr = stderr;
    if ("bufferedData" in error) delete error["bufferedData"];
    return error;
}
function $abcdf0eb4757394f$export$a8f5efe603803b77({ stdout: stdout, stderr: stderr, error: error, exitCode: exitCode, signal: signal, timedOut: timedOut, command: command, options: options, parentError: parentError }) {
    if (error || exitCode !== 0 || signal !== null) {
        const returnedError = $abcdf0eb4757394f$var$makeError({
            error: error,
            exitCode: exitCode,
            signal: signal,
            stdout: stdout,
            stderr: stderr,
            command: command,
            timedOut: timedOut,
            options: options,
            parentError: parentError
        });
        throw returnedError;
    }
    return stdout;
}


const $1621cf84cd51e0ff$var$SPACES_REGEXP = / +/g;
function $1621cf84cd51e0ff$var$parseCommand(command, args) {
    if (args) return [
        command,
        ...args
    ];
    const tokens = [];
    for (const token of command.trim().split($1621cf84cd51e0ff$var$SPACES_REGEXP)){
        // Allow spaces to be escaped by a backslash if not meant as a delimiter
        const previousToken = tokens[tokens.length - 1];
        if (previousToken && previousToken.endsWith("\\")) // Merge previous token with current one
        tokens[tokens.length - 1] = `${previousToken.slice(0, -1)} ${token}`;
        else tokens.push(token);
    }
    return tokens;
}
function $1621cf84cd51e0ff$export$3f4d948c82873887(command, optionsOrArgs, options) {
    const { parseOutput: parseOutput, input: input, onData: onData, onWillExecute: onWillExecute, initialData: initialData, execute: execute, keepPreviousData: keepPreviousData, onError: onError, failureToastOptions: failureToastOptions, ...execOptions } = Array.isArray(optionsOrArgs) ? options || {} : optionsOrArgs || {};
    const useCachedPromiseOptions = {
        initialData: initialData,
        execute: execute,
        keepPreviousData: keepPreviousData,
        onError: onError,
        onData: onData,
        onWillExecute: onWillExecute,
        failureToastOptions: failureToastOptions
    };
    const abortable = (0, $8zHUo$react.useRef)(null);
    const parseOutputRef = (0, $07a180af23fbf38b$export$d4b699e2c1148419)(parseOutput || (0, $abcdf0eb4757394f$export$a8f5efe603803b77));
    const fn = (0, $8zHUo$react.useCallback)(async (_command, _args, _options, input)=>{
        const [file, ...args] = $1621cf84cd51e0ff$var$parseCommand(_command, _args);
        const command = [
            file,
            ...args
        ].join(" ");
        const options = {
            stripFinalNewline: true,
            ..._options,
            timeout: _options?.timeout || 10000,
            signal: abortable.current?.signal,
            encoding: _options?.encoding === null ? "buffer" : _options?.encoding || "utf8",
            env: {
                PATH: "/usr/local/bin:/usr/bin:/bin:/usr/sbin:/sbin",
                ...process.env,
                ..._options?.env
            }
        };
        const spawned = (0, ($parcel$interopDefault($8zHUo$nodechild_process))).spawn(file, args, options);
        const spawnedPromise = (0, $abcdf0eb4757394f$export$6e3a9b5342d42997)(spawned, options);
        if (input) spawned.stdin.end(input);
        const [{ error: error, exitCode: exitCode, signal: signal, timedOut: timedOut }, stdoutResult, stderrResult] = await (0, $abcdf0eb4757394f$export$67b768ac9e1c70fa)(spawned, options, spawnedPromise);
        const stdout = (0, $abcdf0eb4757394f$export$200978bbc0b73ca)(options, stdoutResult);
        const stderr = (0, $abcdf0eb4757394f$export$200978bbc0b73ca)(options, stderrResult);
        return parseOutputRef.current({
            stdout: // @ts-expect-error too many generics, I give up
            stdout,
            stderr: // @ts-expect-error too many generics, I give up
            stderr,
            error: error,
            exitCode: exitCode,
            signal: signal,
            timedOut: timedOut,
            command: command,
            options: options,
            parentError: new Error()
        });
    }, [
        parseOutputRef
    ]);
    // @ts-expect-error T can't be a Promise so it's actually the same
    return (0, $a9b0b6f46ce12461$export$b15740c74e256244)(fn, [
        command,
        Array.isArray(optionsOrArgs) ? optionsOrArgs : [],
        execOptions,
        input
    ], {
        ...useCachedPromiseOptions,
        abortable: abortable
    });
}








/* eslint-disable @typescript-eslint/no-explicit-any */ /* eslint-disable @typescript-eslint/ban-ts-comment */ 
const $53b20c72b2df6089$export$f883a24d5edde77c = /* #__PURE__ */ Symbol.for("object-stream.none");
const $53b20c72b2df6089$var$stop = /* #__PURE__ */ Symbol.for("object-stream.stop");
const $53b20c72b2df6089$var$finalSymbol = /* #__PURE__ */ Symbol.for("object-stream.final");
const $53b20c72b2df6089$var$manySymbol = /* #__PURE__ */ Symbol.for("object-stream.many");
const $53b20c72b2df6089$var$flushSymbol = /* #__PURE__ */ Symbol.for("object-stream.flush");
const $53b20c72b2df6089$var$fListSymbol = /* #__PURE__ */ Symbol.for("object-stream.fList");
const $53b20c72b2df6089$var$finalValue = (value)=>({
        [$53b20c72b2df6089$var$finalSymbol]: 1,
        value: value
    });
const $53b20c72b2df6089$export$14badfee79ea396f = (values)=>({
        [$53b20c72b2df6089$var$manySymbol]: 1,
        values: values
    });
const $53b20c72b2df6089$var$isFinalValue = (o)=>o && o[$53b20c72b2df6089$var$finalSymbol] === 1;
const $53b20c72b2df6089$var$isMany = (o)=>o && o[$53b20c72b2df6089$var$manySymbol] === 1;
const $53b20c72b2df6089$var$isFlushable = (o)=>o && o[$53b20c72b2df6089$var$flushSymbol] === 1;
const $53b20c72b2df6089$var$isFunctionList = (o)=>o && o[$53b20c72b2df6089$var$fListSymbol] === 1;
const $53b20c72b2df6089$var$getFinalValue = (o)=>o.value;
const $53b20c72b2df6089$var$getManyValues = (o)=>o.values;
const $53b20c72b2df6089$var$getFunctionList = (o)=>o.fList;
const $53b20c72b2df6089$export$586a8898e7177441 = (a, b)=>{
    const values = a === $53b20c72b2df6089$export$f883a24d5edde77c ? [] : a?.[$53b20c72b2df6089$var$manySymbol] === 1 ? a.values : [
        a
    ];
    if (b === $53b20c72b2df6089$export$f883a24d5edde77c) ;
    else if (b?.[$53b20c72b2df6089$var$manySymbol] === 1) values.push(...b.values);
    else values.push(b);
    return $53b20c72b2df6089$export$14badfee79ea396f(values);
};
const $53b20c72b2df6089$export$fdd9dbe8c8ef20af = (write, final = null)=>{
    const fn = final ? (value)=>value === $53b20c72b2df6089$export$f883a24d5edde77c ? $53b20c72b2df6089$var$finalValue(undefined) : write(value) : write;
    // @ts-ignore
    fn[$53b20c72b2df6089$var$flushSymbol] = 1;
    return fn;
};
const $53b20c72b2df6089$var$setFunctionList = (o, fns)=>{
    o.fList = fns;
    o[$53b20c72b2df6089$var$fListSymbol] = 1;
    return o;
};
// is*NodeStream functions taken from https://github.com/nodejs/node/blob/master/lib/internal/streams/utils.js
const $53b20c72b2df6089$var$isReadableNodeStream = (obj)=>obj && typeof obj.pipe === "function" && typeof obj.on === "function" && (!obj._writableState || (typeof obj._readableState === "object" ? obj._readableState.readable : null) !== false) && // Duplex
    (!obj._writableState || obj._readableState); // Writable has .pipe.
const $53b20c72b2df6089$var$isWritableNodeStream = (obj)=>obj && typeof obj.write === "function" && typeof obj.on === "function" && (!obj._readableState || (typeof obj._writableState === "object" ? obj._writableState.writable : null) !== false); // Duplex
const $53b20c72b2df6089$var$isDuplexNodeStream = (obj)=>obj && typeof obj.pipe === "function" && obj._readableState && typeof obj.on === "function" && typeof obj.write === "function";
const $53b20c72b2df6089$var$isReadableWebStream = (obj)=>obj && globalThis.ReadableStream && obj instanceof globalThis.ReadableStream;
const $53b20c72b2df6089$var$isWritableWebStream = (obj)=>obj && globalThis.WritableStream && obj instanceof globalThis.WritableStream;
const $53b20c72b2df6089$var$isDuplexWebStream = (obj)=>obj && globalThis.ReadableStream && obj.readable instanceof globalThis.ReadableStream && globalThis.WritableStream && obj.writable instanceof globalThis.WritableStream;
const $53b20c72b2df6089$var$groupFunctions = (output, fn, index, fns)=>{
    if ($53b20c72b2df6089$var$isDuplexNodeStream(fn) || !index && $53b20c72b2df6089$var$isReadableNodeStream(fn) || index === fns.length - 1 && $53b20c72b2df6089$var$isWritableNodeStream(fn)) {
        output.push(fn);
        return output;
    }
    if ($53b20c72b2df6089$var$isDuplexWebStream(fn)) {
        output.push((0, $8zHUo$nodestream.Duplex).fromWeb(fn, {
            objectMode: true
        }));
        return output;
    }
    if (!index && $53b20c72b2df6089$var$isReadableWebStream(fn)) {
        output.push((0, $8zHUo$nodestream.Readable).fromWeb(fn, {
            objectMode: true
        }));
        return output;
    }
    if (index === fns.length - 1 && $53b20c72b2df6089$var$isWritableWebStream(fn)) {
        output.push((0, $8zHUo$nodestream.Writable).fromWeb(fn, {
            objectMode: true
        }));
        return output;
    }
    if (typeof fn != "function") throw TypeError("Item #" + index + " is not a proper stream, nor a function.");
    if (!output.length) output.push([]);
    const last = output[output.length - 1];
    if (Array.isArray(last)) last.push(fn);
    else output.push([
        fn
    ]);
    return output;
};
class $53b20c72b2df6089$var$Stop extends Error {
}
const $53b20c72b2df6089$export$bfe5aec46c67bf9d = (fn)=>{
    if (typeof fn != "function") throw TypeError("Only a function is accepted as the first argument");
    // pump variables
    let paused = Promise.resolve();
    let resolvePaused = null;
    const queue = [];
    // pause/resume
    const resume = ()=>{
        if (!resolvePaused) return;
        resolvePaused();
        resolvePaused = null;
        paused = Promise.resolve();
    };
    const pause = ()=>{
        if (resolvePaused) return;
        paused = new Promise((resolve)=>resolvePaused = resolve);
    };
    // eslint-disable-next-line prefer-const
    let stream; // will be assigned later
    // data processing
    const pushResults = (values)=>{
        if (values && typeof values.next == "function") {
            // generator
            queue.push(values);
            return;
        }
        // array
        queue.push(values[Symbol.iterator]());
    };
    const pump = async ()=>{
        while(queue.length){
            await paused;
            const gen = queue[queue.length - 1];
            let result = gen.next();
            if (result && typeof result.then == "function") result = await result;
            if (result.done) {
                queue.pop();
                continue;
            }
            let value = result.value;
            if (value && typeof value.then == "function") value = await value;
            await sanitize(value);
        }
    };
    const sanitize = async (value)=>{
        if (value === undefined || value === null || value === $53b20c72b2df6089$export$f883a24d5edde77c) return;
        if (value === $53b20c72b2df6089$var$stop) throw new $53b20c72b2df6089$var$Stop();
        if ($53b20c72b2df6089$var$isMany(value)) {
            pushResults($53b20c72b2df6089$var$getManyValues(value));
            return pump();
        }
        if ($53b20c72b2df6089$var$isFinalValue(value)) {
            // a final value is not supported, it is treated as a regular value
            value = $53b20c72b2df6089$var$getFinalValue(value);
            return processValue(value);
        }
        if (!stream.push(value)) pause();
    };
    const processChunk = async (chunk, encoding)=>{
        try {
            const value = fn(chunk, encoding);
            await processValue(value);
        } catch (error) {
            if (error instanceof $53b20c72b2df6089$var$Stop) {
                stream.push(null);
                stream.destroy();
                return;
            }
            throw error;
        }
    };
    const processValue = async (value)=>{
        if (value && typeof value.then == "function") // thenable
        return value.then((value)=>processValue(value));
        if (value && typeof value.next == "function") {
            // generator
            pushResults(value);
            return pump();
        }
        return sanitize(value);
    };
    stream = new (0, $8zHUo$nodestream.Duplex)(Object.assign({
        writableObjectMode: true,
        readableObjectMode: true
    }, undefined, {
        write (chunk, encoding, callback) {
            processChunk(chunk, encoding).then(()=>callback(null), (error)=>callback(error));
        },
        final (callback) {
            if (!$53b20c72b2df6089$var$isFlushable(fn)) {
                stream.push(null);
                callback(null);
                return;
            }
            processChunk($53b20c72b2df6089$export$f883a24d5edde77c, null).then(()=>(stream.push(null), callback(null)), (error)=>callback(error));
        },
        read () {
            resume();
        }
    }));
    return stream;
};
const $53b20c72b2df6089$var$produceStreams = (item)=>{
    if (Array.isArray(item)) {
        if (!item.length) return null;
        if (item.length == 1) return item[0] && $53b20c72b2df6089$export$bfe5aec46c67bf9d(item[0]);
        return $53b20c72b2df6089$export$bfe5aec46c67bf9d($53b20c72b2df6089$export$ca954a7249f984a5(...item));
    }
    return item;
};
const $53b20c72b2df6089$var$next = async function*(value, fns, index) {
    for(let i = index; i <= fns.length; ++i){
        if (value && typeof value.then == "function") // thenable
        value = await value;
        if (value === $53b20c72b2df6089$export$f883a24d5edde77c) break;
        if (value === $53b20c72b2df6089$var$stop) throw new $53b20c72b2df6089$var$Stop();
        if ($53b20c72b2df6089$var$isFinalValue(value)) {
            yield $53b20c72b2df6089$var$getFinalValue(value);
            break;
        }
        if ($53b20c72b2df6089$var$isMany(value)) {
            const values = $53b20c72b2df6089$var$getManyValues(value);
            if (i == fns.length) yield* values;
            else for(let j = 0; j < values.length; ++j)yield* $53b20c72b2df6089$var$next(values[j], fns, i);
            break;
        }
        if (value && typeof value.next == "function") {
            // generator
            for(;;){
                let data = value.next();
                if (data && typeof data.then == "function") data = await data;
                if (data.done) break;
                if (i == fns.length) yield data.value;
                else yield* $53b20c72b2df6089$var$next(data.value, fns, i);
            }
            break;
        }
        if (i == fns.length) {
            yield value;
            break;
        }
        const f = fns[i];
        value = f(value);
    }
};
const $53b20c72b2df6089$export$ca954a7249f984a5 = (...fns)=>{
    fns = fns.filter((fn)=>fn).flat(Infinity).map((fn)=>$53b20c72b2df6089$var$isFunctionList(fn) ? $53b20c72b2df6089$var$getFunctionList(fn) : fn).flat(Infinity);
    if (!fns.length) fns = [
        (x)=>x
    ];
    let flushed = false;
    let g = async function*(value) {
        if (flushed) throw Error("Call to a flushed pipe.");
        if (value !== $53b20c72b2df6089$export$f883a24d5edde77c) yield* $53b20c72b2df6089$var$next(value, fns, 0);
        else {
            flushed = true;
            for(let i = 0; i < fns.length; ++i){
                const f = fns[i];
                if ($53b20c72b2df6089$var$isFlushable(f)) yield* $53b20c72b2df6089$var$next(f($53b20c72b2df6089$export$f883a24d5edde77c), fns, i + 1);
            }
        }
    };
    const needToFlush = fns.some((fn)=>$53b20c72b2df6089$var$isFlushable(fn));
    if (needToFlush) g = $53b20c72b2df6089$export$fdd9dbe8c8ef20af(g);
    return $53b20c72b2df6089$var$setFunctionList(g, fns);
};
const $53b20c72b2df6089$var$write = (input, chunk, encoding, callback)=>{
    let error = null;
    try {
        input.write(chunk, encoding, (e)=>callback(e || error));
    } catch (e) {
        error = e;
    }
};
const $53b20c72b2df6089$var$final = (input, callback)=>{
    let error = null;
    try {
        input.end(null, null, (e)=>callback(e || error));
    } catch (e) {
        error = e;
    }
};
const $53b20c72b2df6089$var$read = (output)=>{
    output.resume();
};
function $53b20c72b2df6089$export$2e2bcd8739ae039(fns) {
    fns = fns.flat(Infinity).filter((fn)=>fn);
    const streams = fns.map((fn)=>$53b20c72b2df6089$var$isFunctionList(fn) ? $53b20c72b2df6089$var$getFunctionList(fn) : fn).flat(Infinity).reduce($53b20c72b2df6089$var$groupFunctions, []).map($53b20c72b2df6089$var$produceStreams).filter((s)=>s), input = streams[0], output = streams.reduce((output, item)=>output && output.pipe(item) || item);
    // eslint-disable-next-line prefer-const
    let stream; // will be assigned later
    let writeMethod = (chunk, encoding, callback)=>$53b20c72b2df6089$var$write(input, chunk, encoding, callback), finalMethod = (callback)=>$53b20c72b2df6089$var$final(input, callback), readMethod = ()=>$53b20c72b2df6089$var$read(output);
    if (!$53b20c72b2df6089$var$isWritableNodeStream(input)) {
        writeMethod = (_1, _2, callback)=>callback(null);
        finalMethod = (callback)=>callback(null);
        input.on("end", ()=>stream.end());
    }
    if ($53b20c72b2df6089$var$isReadableNodeStream(output)) {
        output.on("data", (chunk)=>!stream.push(chunk) && output.pause());
        output.on("end", ()=>stream.push(null));
    } else {
        readMethod = ()=>{}; // nop
        output.on("finish", ()=>stream.push(null));
    }
    stream = new (0, $8zHUo$nodestream.Duplex)(Object.assign({
        writableObjectMode: true,
        readableObjectMode: true
    }, {
        readable: $53b20c72b2df6089$var$isReadableNodeStream(output),
        writable: $53b20c72b2df6089$var$isWritableNodeStream(input),
        write: writeMethod,
        final: finalMethod,
        read: readMethod
    }));
    // @ts-ignore
    stream.streams = streams;
    // @ts-ignore
    stream.input = input;
    // @ts-ignore
    stream.output = output;
    if (!$53b20c72b2df6089$var$isReadableNodeStream(output)) stream.resume();
    // connect events
    streams.forEach((item)=>item.on("error", (error)=>stream.emit("error", error)));
    return stream;
}


/* eslint-disable @typescript-eslint/ban-ts-comment */ /* eslint-disable @typescript-eslint/no-explicit-any */ /* eslint-disable no-control-regex */ /* eslint-disable no-useless-escape */ 


const $880a6729adc89c5e$var$fixUtf8Stream = ()=>{
    const stringDecoder = new (0, $8zHUo$nodestring_decoder.StringDecoder)();
    let input = "";
    return (0, $53b20c72b2df6089$export$fdd9dbe8c8ef20af)((chunk)=>{
        if (chunk === (0, $53b20c72b2df6089$export$f883a24d5edde77c)) {
            const result = input + stringDecoder.end();
            input = "";
            return result;
        }
        if (typeof chunk == "string") {
            if (!input) return chunk;
            const result = input + chunk;
            input = "";
            return result;
        }
        if (chunk instanceof Buffer) {
            const result = input + stringDecoder.write(chunk);
            input = "";
            return result;
        }
        throw new TypeError("Expected a string or a Buffer");
    });
};
const $880a6729adc89c5e$var$patterns = {
    value1: /[\"\{\[\]\-\d]|true\b|false\b|null\b|\s{1,256}/y,
    string: /[^\x00-\x1f\"\\]{1,256}|\\[bfnrt\"\\\/]|\\u[\da-fA-F]{4}|\"/y,
    key1: /[\"\}]|\s{1,256}/y,
    colon: /\:|\s{1,256}/y,
    comma: /[\,\]\}]|\s{1,256}/y,
    ws: /\s{1,256}/y,
    numberStart: /\d/y,
    numberDigit: /\d{0,256}/y,
    numberFraction: /[\.eE]/y,
    numberExponent: /[eE]/y,
    numberExpSign: /[-+]/y
};
const $880a6729adc89c5e$var$MAX_PATTERN_SIZE = 16;
const $880a6729adc89c5e$var$values = {
    true: true,
    false: false,
    null: null
}, $880a6729adc89c5e$var$expected = {
    object: "objectStop",
    array: "arrayStop",
    "": "done"
};
// long hexadecimal codes: \uXXXX
const $880a6729adc89c5e$var$fromHex = (s)=>String.fromCharCode(parseInt(s.slice(2), 16));
// short codes: \b \f \n \r \t \" \\ \/
const $880a6729adc89c5e$var$codes = {
    b: "\b",
    f: "\f",
    n: "\n",
    r: "\r",
    t: "\t",
    '"': '"',
    "\\": "\\",
    "/": "/"
};
const $880a6729adc89c5e$var$jsonParser = (options)=>{
    let packKeys = true, packStrings = true, packNumbers = true, streamKeys = true, streamStrings = true, streamNumbers = true, jsonStreaming = false;
    if (options) {
        "packValues" in options && (packKeys = packStrings = packNumbers = options.packValues);
        "packKeys" in options && (packKeys = options.packKeys);
        "packStrings" in options && (packStrings = options.packStrings);
        "packNumbers" in options && (packNumbers = options.packNumbers);
        "streamValues" in options && (streamKeys = streamStrings = streamNumbers = options.streamValues);
        "streamKeys" in options && (streamKeys = options.streamKeys);
        "streamStrings" in options && (streamStrings = options.streamStrings);
        "streamNumbers" in options && (streamNumbers = options.streamNumbers);
        jsonStreaming = options.jsonStreaming;
    }
    !packKeys && (streamKeys = true);
    !packStrings && (streamStrings = true);
    !packNumbers && (streamNumbers = true);
    let done = false, expect = jsonStreaming ? "done" : "value", parent = "", openNumber = false, accumulator = "", buffer = "";
    const stack = [];
    return (0, $53b20c72b2df6089$export$fdd9dbe8c8ef20af)((buf)=>{
        const tokens = [];
        if (buf === (0, $53b20c72b2df6089$export$f883a24d5edde77c)) done = true;
        else buffer += buf;
        let match;
        let value;
        let index = 0;
        main: for(;;)switch(expect){
            case "value1":
            case "value":
                $880a6729adc89c5e$var$patterns.value1.lastIndex = index;
                match = $880a6729adc89c5e$var$patterns.value1.exec(buffer);
                if (!match) {
                    if (done || index + $880a6729adc89c5e$var$MAX_PATTERN_SIZE < buffer.length) {
                        if (index < buffer.length) throw new Error("Parser cannot parse input: expected a value");
                        throw new Error("Parser has expected a value");
                    }
                    break main; // wait for more input
                }
                value = match[0];
                switch(value){
                    case '"':
                        if (streamStrings) tokens.push({
                            name: "startString"
                        });
                        expect = "string";
                        break;
                    case "{":
                        tokens.push({
                            name: "startObject"
                        });
                        stack.push(parent);
                        parent = "object";
                        expect = "key1";
                        break;
                    case "[":
                        tokens.push({
                            name: "startArray"
                        });
                        stack.push(parent);
                        parent = "array";
                        expect = "value1";
                        break;
                    case "]":
                        if (expect !== "value1") throw new Error("Parser cannot parse input: unexpected token ']'");
                        if (openNumber) {
                            if (streamNumbers) tokens.push({
                                name: "endNumber"
                            });
                            openNumber = false;
                            if (packNumbers) {
                                tokens.push({
                                    name: "numberValue",
                                    value: accumulator
                                });
                                accumulator = "";
                            }
                        }
                        tokens.push({
                            name: "endArray"
                        });
                        parent = stack.pop();
                        expect = $880a6729adc89c5e$var$expected[parent];
                        break;
                    case "-":
                        openNumber = true;
                        if (streamNumbers) tokens.push({
                            name: "startNumber"
                        }, {
                            name: "numberChunk",
                            value: "-"
                        });
                        packNumbers && (accumulator = "-");
                        expect = "numberStart";
                        break;
                    case "0":
                        openNumber = true;
                        if (streamNumbers) tokens.push({
                            name: "startNumber"
                        }, {
                            name: "numberChunk",
                            value: "0"
                        });
                        packNumbers && (accumulator = "0");
                        expect = "numberFraction";
                        break;
                    case "1":
                    case "2":
                    case "3":
                    case "4":
                    case "5":
                    case "6":
                    case "7":
                    case "8":
                    case "9":
                        openNumber = true;
                        if (streamNumbers) tokens.push({
                            name: "startNumber"
                        }, {
                            name: "numberChunk",
                            value: value
                        });
                        packNumbers && (accumulator = value);
                        expect = "numberDigit";
                        break;
                    case "true":
                    case "false":
                    case "null":
                        if (buffer.length - index === value.length && !done) break main; // wait for more input
                        tokens.push({
                            name: value + "Value",
                            value: $880a6729adc89c5e$var$values[value]
                        });
                        expect = $880a6729adc89c5e$var$expected[parent];
                        break;
                }
                index += value.length;
                break;
            case "keyVal":
            case "string":
                $880a6729adc89c5e$var$patterns.string.lastIndex = index;
                match = $880a6729adc89c5e$var$patterns.string.exec(buffer);
                if (!match) {
                    if (index < buffer.length && (done || buffer.length - index >= 6)) throw new Error("Parser cannot parse input: escaped characters");
                    if (done) throw new Error("Parser has expected a string value");
                    break main; // wait for more input
                }
                value = match[0];
                if (value === '"') {
                    if (expect === "keyVal") {
                        if (streamKeys) tokens.push({
                            name: "endKey"
                        });
                        if (packKeys) {
                            tokens.push({
                                name: "keyValue",
                                value: accumulator
                            });
                            accumulator = "";
                        }
                        expect = "colon";
                    } else {
                        if (streamStrings) tokens.push({
                            name: "endString"
                        });
                        if (packStrings) {
                            tokens.push({
                                name: "stringValue",
                                value: accumulator
                            });
                            accumulator = "";
                        }
                        expect = $880a6729adc89c5e$var$expected[parent];
                    }
                } else if (value.length > 1 && value.charAt(0) === "\\") {
                    const t = value.length == 2 ? $880a6729adc89c5e$var$codes[value.charAt(1)] : $880a6729adc89c5e$var$fromHex(value);
                    if (expect === "keyVal" ? streamKeys : streamStrings) tokens.push({
                        name: "stringChunk",
                        value: t
                    });
                    if (expect === "keyVal" ? packKeys : packStrings) accumulator += t;
                } else {
                    if (expect === "keyVal" ? streamKeys : streamStrings) tokens.push({
                        name: "stringChunk",
                        value: value
                    });
                    if (expect === "keyVal" ? packKeys : packStrings) accumulator += value;
                }
                index += value.length;
                break;
            case "key1":
            case "key":
                $880a6729adc89c5e$var$patterns.key1.lastIndex = index;
                match = $880a6729adc89c5e$var$patterns.key1.exec(buffer);
                if (!match) {
                    if (index < buffer.length || done) throw new Error("Parser cannot parse input: expected an object key");
                    break main; // wait for more input
                }
                value = match[0];
                if (value === '"') {
                    if (streamKeys) tokens.push({
                        name: "startKey"
                    });
                    expect = "keyVal";
                } else if (value === "}") {
                    if (expect !== "key1") throw new Error("Parser cannot parse input: unexpected token '}'");
                    tokens.push({
                        name: "endObject"
                    });
                    parent = stack.pop();
                    expect = $880a6729adc89c5e$var$expected[parent];
                }
                index += value.length;
                break;
            case "colon":
                $880a6729adc89c5e$var$patterns.colon.lastIndex = index;
                match = $880a6729adc89c5e$var$patterns.colon.exec(buffer);
                if (!match) {
                    if (index < buffer.length || done) throw new Error("Parser cannot parse input: expected ':'");
                    break main; // wait for more input
                }
                value = match[0];
                value === ":" && (expect = "value");
                index += value.length;
                break;
            case "arrayStop":
            case "objectStop":
                $880a6729adc89c5e$var$patterns.comma.lastIndex = index;
                match = $880a6729adc89c5e$var$patterns.comma.exec(buffer);
                if (!match) {
                    if (index < buffer.length || done) throw new Error("Parser cannot parse input: expected ','");
                    break main; // wait for more input
                }
                if (openNumber) {
                    if (streamNumbers) tokens.push({
                        name: "endNumber"
                    });
                    openNumber = false;
                    if (packNumbers) {
                        tokens.push({
                            name: "numberValue",
                            value: accumulator
                        });
                        accumulator = "";
                    }
                }
                value = match[0];
                if (value === ",") expect = expect === "arrayStop" ? "value" : "key";
                else if (value === "}" || value === "]") {
                    if (value === "}" ? expect === "arrayStop" : expect !== "arrayStop") throw new Error("Parser cannot parse input: expected '" + (expect === "arrayStop" ? "]" : "}") + "'");
                    tokens.push({
                        name: value === "}" ? "endObject" : "endArray"
                    });
                    parent = stack.pop();
                    expect = $880a6729adc89c5e$var$expected[parent];
                }
                index += value.length;
                break;
            // number chunks
            case "numberStart":
                $880a6729adc89c5e$var$patterns.numberStart.lastIndex = index;
                match = $880a6729adc89c5e$var$patterns.numberStart.exec(buffer);
                if (!match) {
                    if (index < buffer.length || done) throw new Error("Parser cannot parse input: expected a starting digit");
                    break main; // wait for more input
                }
                value = match[0];
                if (streamNumbers) tokens.push({
                    name: "numberChunk",
                    value: value
                });
                packNumbers && (accumulator += value);
                expect = value === "0" ? "numberFraction" : "numberDigit";
                index += value.length;
                break;
            case "numberDigit":
                $880a6729adc89c5e$var$patterns.numberDigit.lastIndex = index;
                match = $880a6729adc89c5e$var$patterns.numberDigit.exec(buffer);
                if (!match) {
                    if (index < buffer.length || done) throw new Error("Parser cannot parse input: expected a digit");
                    break main; // wait for more input
                }
                value = match[0];
                if (value) {
                    if (streamNumbers) tokens.push({
                        name: "numberChunk",
                        value: value
                    });
                    packNumbers && (accumulator += value);
                    index += value.length;
                } else {
                    if (index < buffer.length) {
                        expect = "numberFraction";
                        break;
                    }
                    if (done) {
                        expect = $880a6729adc89c5e$var$expected[parent];
                        break;
                    }
                    break main; // wait for more input
                }
                break;
            case "numberFraction":
                $880a6729adc89c5e$var$patterns.numberFraction.lastIndex = index;
                match = $880a6729adc89c5e$var$patterns.numberFraction.exec(buffer);
                if (!match) {
                    if (index < buffer.length || done) {
                        expect = $880a6729adc89c5e$var$expected[parent];
                        break;
                    }
                    break main; // wait for more input
                }
                value = match[0];
                if (streamNumbers) tokens.push({
                    name: "numberChunk",
                    value: value
                });
                packNumbers && (accumulator += value);
                expect = value === "." ? "numberFracStart" : "numberExpSign";
                index += value.length;
                break;
            case "numberFracStart":
                $880a6729adc89c5e$var$patterns.numberStart.lastIndex = index;
                match = $880a6729adc89c5e$var$patterns.numberStart.exec(buffer);
                if (!match) {
                    if (index < buffer.length || done) throw new Error("Parser cannot parse input: expected a fractional part of a number");
                    break main; // wait for more input
                }
                value = match[0];
                if (streamNumbers) tokens.push({
                    name: "numberChunk",
                    value: value
                });
                packNumbers && (accumulator += value);
                expect = "numberFracDigit";
                index += value.length;
                break;
            case "numberFracDigit":
                $880a6729adc89c5e$var$patterns.numberDigit.lastIndex = index;
                match = $880a6729adc89c5e$var$patterns.numberDigit.exec(buffer);
                value = match[0];
                if (value) {
                    if (streamNumbers) tokens.push({
                        name: "numberChunk",
                        value: value
                    });
                    packNumbers && (accumulator += value);
                    index += value.length;
                } else {
                    if (index < buffer.length) {
                        expect = "numberExponent";
                        break;
                    }
                    if (done) {
                        expect = $880a6729adc89c5e$var$expected[parent];
                        break;
                    }
                    break main; // wait for more input
                }
                break;
            case "numberExponent":
                $880a6729adc89c5e$var$patterns.numberExponent.lastIndex = index;
                match = $880a6729adc89c5e$var$patterns.numberExponent.exec(buffer);
                if (!match) {
                    if (index < buffer.length) {
                        expect = $880a6729adc89c5e$var$expected[parent];
                        break;
                    }
                    if (done) {
                        expect = "done";
                        break;
                    }
                    break main; // wait for more input
                }
                value = match[0];
                if (streamNumbers) tokens.push({
                    name: "numberChunk",
                    value: value
                });
                packNumbers && (accumulator += value);
                expect = "numberExpSign";
                index += value.length;
                break;
            case "numberExpSign":
                $880a6729adc89c5e$var$patterns.numberExpSign.lastIndex = index;
                match = $880a6729adc89c5e$var$patterns.numberExpSign.exec(buffer);
                if (!match) {
                    if (index < buffer.length) {
                        expect = "numberExpStart";
                        break;
                    }
                    if (done) throw new Error("Parser has expected an exponent value of a number");
                    break main; // wait for more input
                }
                value = match[0];
                if (streamNumbers) tokens.push({
                    name: "numberChunk",
                    value: value
                });
                packNumbers && (accumulator += value);
                expect = "numberExpStart";
                index += value.length;
                break;
            case "numberExpStart":
                $880a6729adc89c5e$var$patterns.numberStart.lastIndex = index;
                match = $880a6729adc89c5e$var$patterns.numberStart.exec(buffer);
                if (!match) {
                    if (index < buffer.length || done) throw new Error("Parser cannot parse input: expected an exponent part of a number");
                    break main; // wait for more input
                }
                value = match[0];
                if (streamNumbers) tokens.push({
                    name: "numberChunk",
                    value: value
                });
                packNumbers && (accumulator += value);
                expect = "numberExpDigit";
                index += value.length;
                break;
            case "numberExpDigit":
                $880a6729adc89c5e$var$patterns.numberDigit.lastIndex = index;
                match = $880a6729adc89c5e$var$patterns.numberDigit.exec(buffer);
                value = match[0];
                if (value) {
                    if (streamNumbers) tokens.push({
                        name: "numberChunk",
                        value: value
                    });
                    packNumbers && (accumulator += value);
                    index += value.length;
                } else {
                    if (index < buffer.length || done) {
                        expect = $880a6729adc89c5e$var$expected[parent];
                        break;
                    }
                    break main; // wait for more input
                }
                break;
            case "done":
                $880a6729adc89c5e$var$patterns.ws.lastIndex = index;
                match = $880a6729adc89c5e$var$patterns.ws.exec(buffer);
                if (!match) {
                    if (index < buffer.length) {
                        if (jsonStreaming) {
                            expect = "value";
                            break;
                        }
                        throw new Error("Parser cannot parse input: unexpected characters");
                    }
                    break main; // wait for more input
                }
                value = match[0];
                if (openNumber) {
                    if (streamNumbers) tokens.push({
                        name: "endNumber"
                    });
                    openNumber = false;
                    if (packNumbers) {
                        tokens.push({
                            name: "numberValue",
                            value: accumulator
                        });
                        accumulator = "";
                    }
                }
                index += value.length;
                break;
        }
        if (done && openNumber) {
            if (streamNumbers) tokens.push({
                name: "endNumber"
            });
            openNumber = false;
            if (packNumbers) {
                tokens.push({
                    name: "numberValue",
                    value: accumulator
                });
                accumulator = "";
            }
        }
        buffer = buffer.slice(index);
        return tokens.length ? (0, $53b20c72b2df6089$export$14badfee79ea396f)(tokens) : (0, $53b20c72b2df6089$export$f883a24d5edde77c);
    });
};
const $880a6729adc89c5e$export$8f49e4af10703ce3 = (options)=>(0, $53b20c72b2df6089$export$ca954a7249f984a5)($880a6729adc89c5e$var$fixUtf8Stream(), $880a6729adc89c5e$var$jsonParser(options));
const $880a6729adc89c5e$var$withParser = (fn, options)=>(0, $53b20c72b2df6089$export$ca954a7249f984a5)($880a6729adc89c5e$export$8f49e4af10703ce3(options), fn(options));
const $880a6729adc89c5e$var$checkableTokens = {
    startObject: 1,
    startArray: 1,
    startString: 1,
    startNumber: 1,
    nullValue: 1,
    trueValue: 1,
    falseValue: 1,
    stringValue: 1,
    numberValue: 1
}, $880a6729adc89c5e$var$stopTokens = {
    startObject: "endObject",
    startArray: "endArray",
    startString: "endString",
    startNumber: "endNumber"
}, $880a6729adc89c5e$var$optionalTokens = {
    endString: "stringValue",
    endNumber: "numberValue"
};
const $880a6729adc89c5e$var$defaultFilter = (_stack, _a)=>true;
const $880a6729adc89c5e$var$stringFilter = (string, separator)=>{
    const stringWithSeparator = string + separator;
    return (stack, _a)=>{
        const path = stack.join(separator);
        return path === string || path.startsWith(stringWithSeparator);
    };
};
const $880a6729adc89c5e$var$regExpFilter = (regExp, separator)=>{
    return (stack, _a)=>regExp.test(stack.join(separator));
};
const $880a6729adc89c5e$var$filterBase = ({ specialAction: specialAction = "accept", defaultAction: defaultAction = "ignore", nonCheckableAction: nonCheckableAction = "process-key", transition: transition } = {})=>(options)=>{
        const once = options?.once, separator = options?.pathSeparator || ".";
        let filter = $880a6729adc89c5e$var$defaultFilter, streamKeys = true;
        if (options) {
            if (typeof options.filter == "function") filter = options.filter;
            else if (typeof options.filter == "string") filter = $880a6729adc89c5e$var$stringFilter(options.filter, separator);
            else if (options.filter instanceof RegExp) filter = $880a6729adc89c5e$var$regExpFilter(options.filter, separator);
            if ("streamValues" in options) streamKeys = options.streamValues;
            if ("streamKeys" in options) streamKeys = options.streamKeys;
        }
        const sanitizedOptions = Object.assign({}, options, {
            filter: filter,
            streamKeys: streamKeys,
            separator: separator
        });
        let state = "check";
        const stack = [];
        let depth = 0, previousToken = "", endToken = "", optionalToken = "", startTransition = false;
        return (0, $53b20c72b2df6089$export$fdd9dbe8c8ef20af)((chunk)=>{
            // the flush
            if (chunk === (0, $53b20c72b2df6089$export$f883a24d5edde77c)) return transition ? transition([], null, "flush", sanitizedOptions) : (0, $53b20c72b2df6089$export$f883a24d5edde77c);
            // process the optional value token (unfinished)
            if (optionalToken) {
                if (optionalToken === chunk.name) {
                    let returnToken = (0, $53b20c72b2df6089$export$f883a24d5edde77c);
                    switch(state){
                        case "process-key":
                            stack[stack.length - 1] = chunk.value;
                            state = "check";
                            break;
                        case "accept-value":
                            returnToken = chunk;
                            state = once ? "pass" : "check";
                            break;
                        default:
                            state = once ? "all" : "check";
                            break;
                    }
                    optionalToken = "";
                    return returnToken;
                }
                optionalToken = "";
                state = once && state !== "process-key" ? "pass" : "check";
            }
            let returnToken = (0, $53b20c72b2df6089$export$f883a24d5edde77c);
            recheck: for(;;){
                // accept/reject tokens
                switch(state){
                    case "process-key":
                        if (chunk.name === "endKey") optionalToken = "keyValue";
                        return 0, $53b20c72b2df6089$export$f883a24d5edde77c;
                    case "pass":
                        return 0, $53b20c72b2df6089$export$f883a24d5edde77c;
                    case "all":
                        return chunk;
                    case "accept":
                    case "reject":
                        if (startTransition) {
                            startTransition = false;
                            returnToken = transition(stack, chunk, state, sanitizedOptions) || (0, $53b20c72b2df6089$export$f883a24d5edde77c);
                        }
                        switch(chunk.name){
                            case "startObject":
                            case "startArray":
                                ++depth;
                                break;
                            case "endObject":
                            case "endArray":
                                --depth;
                                break;
                        }
                        if (state === "accept") returnToken = (0, $53b20c72b2df6089$export$586a8898e7177441)(returnToken, chunk);
                        if (!depth) {
                            if (once) state = state === "accept" ? "pass" : "all";
                            else state = "check";
                        }
                        return returnToken;
                    case "accept-value":
                    case "reject-value":
                        if (startTransition) {
                            startTransition = false;
                            returnToken = transition(stack, chunk, state, sanitizedOptions) || (0, $53b20c72b2df6089$export$f883a24d5edde77c);
                        }
                        if (state === "accept-value") returnToken = (0, $53b20c72b2df6089$export$586a8898e7177441)(returnToken, chunk);
                        if (chunk.name === endToken) {
                            // @ts-ignore
                            optionalToken = $880a6729adc89c5e$var$optionalTokens[endToken] || "";
                            endToken = "";
                            if (!optionalToken) {
                                if (once) state = state === "accept-value" ? "pass" : "all";
                                else state = "check";
                            }
                        }
                        return returnToken;
                }
                // update the last index in the stack
                if (typeof stack[stack.length - 1] == "number") // array
                switch(chunk.name){
                    case "startObject":
                    case "startArray":
                    case "startString":
                    case "startNumber":
                    case "nullValue":
                    case "trueValue":
                    case "falseValue":
                        ++stack[stack.length - 1];
                        break;
                    case "numberValue":
                        if (previousToken !== "endNumber") ++stack[stack.length - 1];
                        break;
                    case "stringValue":
                        if (previousToken !== "endString") ++stack[stack.length - 1];
                        break;
                }
                else if (chunk.name === "keyValue") stack[stack.length - 1] = chunk.value;
                previousToken = chunk.name;
                // check the token
                const action = // @ts-ignore
                $880a6729adc89c5e$var$checkableTokens[chunk.name] !== 1 ? nonCheckableAction : filter(stack, chunk) ? specialAction : defaultAction;
                // @ts-ignore
                endToken = $880a6729adc89c5e$var$stopTokens[chunk.name] || "";
                switch(action){
                    case "process-key":
                        if (chunk.name === "startKey") {
                            state = "process-key";
                            continue recheck;
                        }
                        break;
                    case "accept-token":
                        // @ts-ignore
                        if (endToken && $880a6729adc89c5e$var$optionalTokens[endToken]) {
                            state = "accept-value";
                            startTransition = !!transition;
                            continue recheck;
                        }
                        if (transition) returnToken = transition(stack, chunk, action, sanitizedOptions);
                        returnToken = (0, $53b20c72b2df6089$export$586a8898e7177441)(returnToken, chunk);
                        break;
                    case "accept":
                        if (endToken) {
                            // @ts-ignore
                            state = $880a6729adc89c5e$var$optionalTokens[endToken] ? "accept-value" : "accept";
                            startTransition = !!transition;
                            continue recheck;
                        }
                        if (transition) returnToken = transition(stack, chunk, action, sanitizedOptions);
                        returnToken = (0, $53b20c72b2df6089$export$586a8898e7177441)(returnToken, chunk);
                        break;
                    case "reject":
                        if (endToken) {
                            // @ts-ignore
                            state = $880a6729adc89c5e$var$optionalTokens[endToken] ? "reject-value" : "reject";
                            startTransition = !!transition;
                            continue recheck;
                        }
                        if (transition) returnToken = transition(stack, chunk, action, sanitizedOptions);
                        break;
                    case "pass":
                        state = "pass";
                        continue recheck;
                }
                break;
            }
            // update the stack
            switch(chunk.name){
                case "startObject":
                    stack.push(null);
                    break;
                case "startArray":
                    stack.push(-1);
                    break;
                case "endObject":
                case "endArray":
                    stack.pop();
                    break;
            }
            return returnToken;
        });
    };
const $880a6729adc89c5e$export$6f5a5bbde77b52cd = (options)=>$880a6729adc89c5e$var$withParser($880a6729adc89c5e$var$filterBase(), Object.assign({
        packKeys: true
    }, options));
class $880a6729adc89c5e$var$Counter {
    constructor(initialDepth){
        this.depth = initialDepth;
    }
    startObject() {
        ++this.depth;
    }
    endObject() {
        --this.depth;
    }
    startArray() {
        ++this.depth;
    }
    endArray() {
        --this.depth;
    }
}
class $880a6729adc89c5e$var$Assembler extends (0, ($parcel$interopDefault($8zHUo$nodeevents))) {
    static connectTo(stream, options) {
        return new $880a6729adc89c5e$var$Assembler(options).connectTo(stream);
    }
    constructor(options){
        super();
        this.stack = [];
        this.current = this.key = null;
        this.done = true;
        if (options) {
            this.reviver = typeof options.reviver == "function" && options.reviver;
            if (this.reviver) this.stringValue = this._saveValue = this._saveValueWithReviver;
            if (options.numberAsString) // @ts-ignore
            this.numberValue = this.stringValue;
        }
        this.tapChain = (chunk)=>{
            // @ts-ignore
            if (this[chunk.name]) {
                // @ts-ignore
                this[chunk.name](chunk.value);
                if (this.done) return this.current;
            }
            return 0, $53b20c72b2df6089$export$f883a24d5edde77c;
        };
        this.stringValue = this._saveValue;
    }
    connectTo(stream) {
        stream.on("data", (chunk)=>{
            // @ts-ignore
            if (this[chunk.name]) {
                // @ts-ignore
                this[chunk.name](chunk.value);
                // @ts-ignore
                if (this.done) this.emit("done", this);
            }
        });
        return this;
    }
    get depth() {
        return (this.stack.length >> 1) + (this.done ? 0 : 1);
    }
    get path() {
        const path = [];
        for(let i = 0; i < this.stack.length; i += 2){
            const key = this.stack[i + 1];
            path.push(key === null ? this.stack[i].length : key);
        }
        return path;
    }
    dropToLevel(level) {
        if (level < this.depth) {
            if (level > 0) {
                const index = level - 1 << 1;
                this.current = this.stack[index];
                this.key = this.stack[index + 1];
                this.stack.splice(index);
            } else {
                this.stack = [];
                this.current = this.key = null;
                this.done = true;
            }
        }
        return this;
    }
    consume(chunk) {
        // @ts-ignore
        this[chunk.name] && this[chunk.name](chunk.value);
        return this;
    }
    keyValue(value) {
        this.key = value;
    }
    //stringValue() - aliased below to _saveValue()
    numberValue(value) {
        this._saveValue(parseFloat(value));
    }
    nullValue() {
        this._saveValue(null);
    }
    trueValue() {
        this._saveValue(true);
    }
    falseValue() {
        this._saveValue(false);
    }
    startObject() {
        if (this.done) this.done = false;
        else this.stack.push(this.current, this.key);
        this.current = new Object();
        this.key = null;
    }
    endObject() {
        if (this.stack.length) {
            const value = this.current;
            this.key = this.stack.pop();
            this.current = this.stack.pop();
            this._saveValue(value);
        } else this.done = true;
    }
    startArray() {
        if (this.done) this.done = false;
        else this.stack.push(this.current, this.key);
        this.current = [];
        this.key = null;
    }
    endArray() {
        if (this.stack.length) {
            const value = this.current;
            this.key = this.stack.pop();
            this.current = this.stack.pop();
            this._saveValue(value);
        } else this.done = true;
    }
    _saveValue(value) {
        if (this.done) this.current = value;
        else if (this.current instanceof Array) this.current.push(value);
        else {
            this.current[this.key] = value;
            this.key = null;
        }
    }
    _saveValueWithReviver(value) {
        if (this.done) this.current = this.reviver("", value);
        else if (this.current instanceof Array) {
            value = this.reviver("" + this.current.length, value);
            this.current.push(value);
            if (value === undefined) delete this.current[this.current.length - 1];
        } else {
            value = this.reviver(this.key, value);
            if (value !== undefined) this.current[this.key] = value;
            this.key = null;
        }
    }
}
const $880a6729adc89c5e$var$streamBase = ({ push: push, first: first, level: level })=>(options = {})=>{
        const { objectFilter: objectFilter, includeUndecided: includeUndecided } = options;
        let asm = new $880a6729adc89c5e$var$Assembler(options), state = first ? "first" : "check", savedAsm = null;
        if (typeof objectFilter != "function") {
            // no object filter + no first check
            if (state === "check") return (chunk)=>{
                if (asm[chunk.name]) {
                    asm[chunk.name](chunk.value);
                    if (asm.depth === level) return push(asm);
                }
                return 0, $53b20c72b2df6089$export$f883a24d5edde77c;
            };
            // no object filter
            return (chunk)=>{
                switch(state){
                    case "first":
                        first(chunk);
                        state = "accept";
                    // fall through
                    case "accept":
                        if (asm[chunk.name]) {
                            asm[chunk.name](chunk.value);
                            if (asm.depth === level) return push(asm);
                        }
                        break;
                }
                return 0, $53b20c72b2df6089$export$f883a24d5edde77c;
            };
        }
        // object filter + a possible first check
        return (chunk)=>{
            switch(state){
                case "first":
                    first(chunk);
                    state = "check";
                // fall through
                case "check":
                    if (asm[chunk.name]) {
                        asm[chunk.name](chunk.value);
                        const result = objectFilter(asm);
                        if (result) {
                            state = "accept";
                            if (asm.depth === level) return push(asm);
                        } else if (result === false) {
                            if (asm.depth === level) return push(asm, true);
                            state = "reject";
                            savedAsm = asm;
                            asm = new $880a6729adc89c5e$var$Counter(savedAsm.depth);
                            savedAsm.dropToLevel(level);
                        } else {
                            if (asm.depth === level) return push(asm, !includeUndecided);
                        }
                    }
                    break;
                case "accept":
                    if (asm[chunk.name]) {
                        asm[chunk.name](chunk.value);
                        if (asm.depth === level) {
                            state = "check";
                            return push(asm);
                        }
                    }
                    break;
                case "reject":
                    if (asm[chunk.name]) {
                        asm[chunk.name](chunk.value);
                        if (asm.depth === level) {
                            state = "check";
                            asm = savedAsm;
                            savedAsm = null;
                            return push(asm, true);
                        }
                    }
                    break;
            }
            return 0, $53b20c72b2df6089$export$f883a24d5edde77c;
        };
    };
const $880a6729adc89c5e$export$d3281d37ba37c73c = (options)=>{
    let key = 0;
    return $880a6729adc89c5e$var$streamBase({
        level: 1,
        first (chunk) {
            if (chunk.name !== "startArray") throw new Error("Top-level object should be an array.");
        },
        push (asm, discard) {
            if (asm.current.length) {
                if (discard) {
                    ++key;
                    asm.current.pop();
                } else return {
                    key: key++,
                    value: asm.current.pop()
                };
            }
            return 0, $53b20c72b2df6089$export$f883a24d5edde77c;
        }
    })(options);
};





async function $3122cfee675f370d$var$cache(url, destination, fetchOptions) {
    if (typeof url === "object" || url.startsWith("http://") || url.startsWith("https://")) return await $3122cfee675f370d$var$cacheURL(url, destination, fetchOptions);
    else if (url.startsWith("file://")) return await $3122cfee675f370d$var$cacheFile((0, $8zHUo$nodepath.normalize)(decodeURIComponent(new URL(url).pathname)), destination, fetchOptions?.signal ? fetchOptions.signal : undefined);
    else throw new Error("Only HTTP(S) or file URLs are supported");
}
async function $3122cfee675f370d$var$cacheURL(url, destination, fetchOptions) {
    const response = await fetch(url, fetchOptions);
    if (!response.ok) throw new Error("Failed to fetch URL");
    if (!(0, $5c00fc5faeba62a7$export$3427e80ee71d60ba)(response.headers.get("content-type"))) throw new Error("URL does not return JSON");
    if (!response.body) throw new Error("Failed to retrieve expected JSON content: Response body is missing or inaccessible.");
    await (0, $8zHUo$nodestreampromises.pipeline)(response.body, (0, $8zHUo$nodefs.createWriteStream)(destination), fetchOptions?.signal ? {
        signal: fetchOptions.signal
    } : undefined);
}
async function $3122cfee675f370d$var$cacheFile(source, destination, abortSignal) {
    await (0, $8zHUo$nodestreampromises.pipeline)((0, $8zHUo$nodefs.createReadStream)(source), (0, $8zHUo$nodefs.createWriteStream)(destination), abortSignal ? {
        signal: abortSignal
    } : undefined);
}
async function $3122cfee675f370d$var$cacheURLIfNecessary(url, folder, fileName, forceUpdate, fetchOptions) {
    const destination = (0, $8zHUo$nodepath.join)(folder, fileName);
    try {
        await (0, $8zHUo$nodefspromises.stat)(folder);
    } catch (e) {
        (0, $8zHUo$nodefs.mkdirSync)(folder, {
            recursive: true
        });
        await $3122cfee675f370d$var$cache(url, destination, fetchOptions);
        return;
    }
    if (forceUpdate) {
        await $3122cfee675f370d$var$cache(url, destination, fetchOptions);
        return;
    }
    let stats = undefined;
    try {
        stats = await (0, $8zHUo$nodefspromises.stat)(destination);
    } catch (e) {
        await $3122cfee675f370d$var$cache(url, destination, fetchOptions);
        return;
    }
    if (typeof url === "object" || url.startsWith("http://") || url.startsWith("https://")) {
        const headResponse = await fetch(url, {
            ...fetchOptions,
            method: "HEAD"
        });
        if (!headResponse.ok) throw new Error("Could not fetch URL");
        if (!(0, $5c00fc5faeba62a7$export$3427e80ee71d60ba)(headResponse.headers.get("content-type"))) throw new Error("URL does not return JSON");
        const lastModified = Date.parse(headResponse.headers.get("last-modified") ?? "");
        if (stats.size === 0 || Number.isNaN(lastModified) || lastModified > stats.mtimeMs) {
            await $3122cfee675f370d$var$cache(url, destination, fetchOptions);
            return;
        }
    } else if (url.startsWith("file://")) try {
        const sourceStats = await (0, $8zHUo$nodefspromises.stat)((0, $8zHUo$nodepath.normalize)(decodeURIComponent(new URL(url).pathname)));
        if (sourceStats.mtimeMs > stats.mtimeMs) await $3122cfee675f370d$var$cache(url, destination, fetchOptions);
    } catch (e) {
        throw new Error("Source file could not be read");
    }
    else throw new Error("Only HTTP(S) or file URLs are supported");
}
async function* $3122cfee675f370d$var$streamJsonFile(filePath, pageSize, abortSignal, dataPath, filterFn, transformFn) {
    let page = [];
    const pipeline = (0, $53b20c72b2df6089$export$2e2bcd8739ae039)([
        (0, $8zHUo$nodefs.createReadStream)(filePath),
        dataPath ? (0, $880a6729adc89c5e$export$6f5a5bbde77b52cd)({
            filter: dataPath
        }) : (0, $880a6729adc89c5e$export$8f49e4af10703ce3)(),
        (0, $880a6729adc89c5e$export$d3281d37ba37c73c)(),
        (data)=>transformFn?.(data.value) ?? data.value
    ]);
    abortSignal?.addEventListener("abort", ()=>{
        pipeline.destroy();
    });
    try {
        for await (const data of pipeline){
            if (abortSignal?.aborted) return [];
            if (!filterFn || filterFn(data)) page.push(data);
            if (page.length >= pageSize) {
                yield page;
                page = [];
            }
        }
    } catch (e) {
        pipeline.destroy();
        throw e;
    }
    if (page.length > 0) yield page;
    return [];
}
function $3122cfee675f370d$export$48c74caed1925dc8(url, options) {
    const { initialData: initialData, execute: execute, keepPreviousData: keepPreviousData, onError: onError, onData: onData, onWillExecute: onWillExecute, failureToastOptions: failureToastOptions, dataPath: dataPath, filter: filter, transform: transform, pageSize: pageSize = 20, ...fetchOptions } = options ?? {};
    const previousUrl = (0, $8zHUo$react.useRef)(null);
    const previousDestination = (0, $8zHUo$react.useRef)(null);
    const useCachedPromiseOptions = {
        initialData: initialData,
        execute: execute,
        keepPreviousData: keepPreviousData,
        onError: onError,
        onData: onData,
        onWillExecute: onWillExecute,
        failureToastOptions: failureToastOptions
    };
    const generatorRef = (0, $8zHUo$react.useRef)(null);
    const controllerRef = (0, $8zHUo$react.useRef)(null);
    const hasMoreRef = (0, $8zHUo$react.useRef)(false);
    return (0, $a9b0b6f46ce12461$export$b15740c74e256244)((url, pageSize, fetchOptions, dataPath, filter, transform)=>async ({ page: page })=>{
            const fileName = (0, $dfecd32049fa58e9$export$d6af199866bfb566)(url) + ".json";
            const folder = (0, $8zHUo$raycastapi.environment).supportPath;
            if (page === 0) {
                controllerRef.current?.abort();
                controllerRef.current = new AbortController();
                const destination = (0, $8zHUo$nodepath.join)(folder, fileName);
                /**
           * Force update the cache when the URL changes but the cache destination does not.
           */ const forceCacheUpdate = Boolean(previousUrl.current && previousUrl.current !== url && previousDestination.current && previousDestination.current === destination);
                previousUrl.current = url;
                previousDestination.current = destination;
                await $3122cfee675f370d$var$cacheURLIfNecessary(url, folder, fileName, forceCacheUpdate, {
                    ...fetchOptions,
                    signal: controllerRef.current?.signal
                });
                generatorRef.current = $3122cfee675f370d$var$streamJsonFile(destination, pageSize, controllerRef.current?.signal, dataPath, filter, transform);
            }
            if (!generatorRef.current) return {
                hasMore: hasMoreRef.current,
                data: []
            };
            const { value: newData, done: done } = await generatorRef.current.next();
            hasMoreRef.current = !done;
            return {
                hasMore: hasMoreRef.current,
                data: newData ?? []
            };
        }, [
        url,
        pageSize,
        fetchOptions,
        dataPath,
        filter,
        transform
    ], useCachedPromiseOptions);
}

















class $832d6ad39638ce0c$export$cb7dc23b705f5c86 extends Error {
    constructor(message){
        super(message);
        this.name = "PermissionError";
    }
}
function $832d6ad39638ce0c$export$e11674744930cd15(error) {
    return error instanceof Error && error.name === "PermissionError";
}
async function $832d6ad39638ce0c$export$4cff4f142f384da7(databasePath, query, options) {
    if (!(0, $8zHUo$nodefs.existsSync)(databasePath)) throw new Error("The database does not exist");
    let sqlite3;
    try {
        // this is a bit ugly but we can't directly import "node:sqlite" here because parcel will hoist it anyway and it will break when it's not available
        const dynamicImport = (module)=>import(module);
        sqlite3 = await dynamicImport("node:sqlite");
    } catch (error) {
        // If sqlite3 is not available, we fallback to using the sqlite3 CLI (available on macOS and Linux by default).
        return $832d6ad39638ce0c$var$sqliteFallback(databasePath, query, options);
    }
    let db = new sqlite3.DatabaseSync(databasePath, {
        open: false,
        readOnly: true
    });
    const abortSignal = options?.signal;
    try {
        db.open();
    } catch (error) {
        console.log(error);
        if (error.message.match("(5)") || error.message.match("(14)")) {
            // That means that the DB is busy because of another app is locking it
            // This happens when Chrome or Arc is opened: they lock the History db.
            // As an ugly workaround, we duplicate the file and read that instead
            // (with vfs unix - none to just not care about locks)
            let workaroundCopiedDb;
            if (!workaroundCopiedDb) {
                const tempFolder = (0, ($parcel$interopDefault($8zHUo$nodepath))).join((0, ($parcel$interopDefault($8zHUo$nodeos))).tmpdir(), "useSQL", (0, $dfecd32049fa58e9$export$d6af199866bfb566)(databasePath));
                await (0, $8zHUo$nodefspromises.mkdir)(tempFolder, {
                    recursive: true
                });
                $832d6ad39638ce0c$var$checkAborted(abortSignal);
                workaroundCopiedDb = (0, ($parcel$interopDefault($8zHUo$nodepath))).join(tempFolder, "db.db");
                await (0, $8zHUo$nodefspromises.copyFile)(databasePath, workaroundCopiedDb);
                await (0, $8zHUo$nodefspromises.writeFile)(workaroundCopiedDb + "-shm", "");
                await (0, $8zHUo$nodefspromises.writeFile)(workaroundCopiedDb + "-wal", "");
                $832d6ad39638ce0c$var$checkAborted(abortSignal);
            }
            db = new sqlite3.DatabaseSync(workaroundCopiedDb, {
                open: false,
                readOnly: true
            });
            db.open();
            $832d6ad39638ce0c$var$checkAborted(abortSignal);
        }
    }
    const statement = db.prepare(query);
    $832d6ad39638ce0c$var$checkAborted(abortSignal);
    const result = statement.all();
    db.close();
    return result;
}
async function $832d6ad39638ce0c$var$sqliteFallback(databasePath, query, options) {
    const abortSignal = options?.signal;
    let spawned = (0, ($parcel$interopDefault($8zHUo$nodechild_process))).spawn("sqlite3", [
        "--json",
        "--readonly",
        databasePath,
        query
    ], {
        signal: abortSignal
    });
    let spawnedPromise = (0, $abcdf0eb4757394f$export$6e3a9b5342d42997)(spawned);
    let [{ error: error, exitCode: exitCode, signal: signal }, stdoutResult, stderrResult] = await (0, $abcdf0eb4757394f$export$67b768ac9e1c70fa)(spawned, {
        encoding: "utf-8"
    }, spawnedPromise);
    $832d6ad39638ce0c$var$checkAborted(abortSignal);
    if (stderrResult.match("(5)") || stderrResult.match("(14)")) {
        // That means that the DB is busy because of another app is locking it
        // This happens when Chrome or Arc is opened: they lock the History db.
        // As an ugly workaround, we duplicate the file and read that instead
        // (with vfs unix - none to just not care about locks)
        let workaroundCopiedDb;
        if (!workaroundCopiedDb) {
            const tempFolder = (0, ($parcel$interopDefault($8zHUo$nodepath))).join((0, ($parcel$interopDefault($8zHUo$nodeos))).tmpdir(), "useSQL", (0, $dfecd32049fa58e9$export$d6af199866bfb566)(databasePath));
            await (0, $8zHUo$nodefspromises.mkdir)(tempFolder, {
                recursive: true
            });
            $832d6ad39638ce0c$var$checkAborted(abortSignal);
            workaroundCopiedDb = (0, ($parcel$interopDefault($8zHUo$nodepath))).join(tempFolder, "db.db");
            await (0, $8zHUo$nodefspromises.copyFile)(databasePath, workaroundCopiedDb);
            await (0, $8zHUo$nodefspromises.writeFile)(workaroundCopiedDb + "-shm", "");
            await (0, $8zHUo$nodefspromises.writeFile)(workaroundCopiedDb + "-wal", "");
            $832d6ad39638ce0c$var$checkAborted(abortSignal);
        }
        spawned = (0, ($parcel$interopDefault($8zHUo$nodechild_process))).spawn("sqlite3", [
            "--json",
            "--readonly",
            "--vfs",
            "unix-none",
            workaroundCopiedDb,
            query
        ], {
            signal: abortSignal
        });
        spawnedPromise = (0, $abcdf0eb4757394f$export$6e3a9b5342d42997)(spawned);
        [{ error: error, exitCode: exitCode, signal: signal }, stdoutResult, stderrResult] = await (0, $abcdf0eb4757394f$export$67b768ac9e1c70fa)(spawned, {
            encoding: "utf-8"
        }, spawnedPromise);
        $832d6ad39638ce0c$var$checkAborted(abortSignal);
    }
    if (error || exitCode !== 0 || signal !== null) {
        if (stderrResult.includes("authorization denied")) throw new $832d6ad39638ce0c$export$cb7dc23b705f5c86("You do not have permission to access the database.");
        else throw new Error(stderrResult || "Unknown error");
    }
    return JSON.parse(stdoutResult.trim() || "[]");
}
function $832d6ad39638ce0c$var$checkAborted(signal) {
    if (signal?.aborted) {
        const error = new Error("aborted");
        error.name = "AbortError";
        throw error;
    }
}


function $908f00f283581e25$export$d74ef0af94fb1db6(databasePath, query, options) {
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    const { permissionPriming: permissionPriming, ...usePromiseOptions } = options || {};
    const [permissionView, setPermissionView] = (0, $8zHUo$react.useState)(null);
    const latestOptions = (0, $07a180af23fbf38b$export$d4b699e2c1148419)(options || {});
    const abortable = (0, $8zHUo$react.useRef)(null);
    const handleError = (0, $8zHUo$react.useCallback)((_error)=>{
        console.error(_error);
        const error = _error instanceof Error && _error.message.includes("authorization denied") ? new (0, $832d6ad39638ce0c$export$cb7dc23b705f5c86)("You do not have permission to access the database.") : _error;
        if ((0, $832d6ad39638ce0c$export$e11674744930cd15)(error)) setPermissionView(/*#__PURE__*/ (0, $8zHUo$reactjsxruntime.jsx)($908f00f283581e25$var$PermissionErrorScreen, {
            priming: latestOptions.current.permissionPriming
        }));
        else {
            if (latestOptions.current.onError) latestOptions.current.onError(error);
            else if ((0, $8zHUo$raycastapi.environment).launchType !== (0, $8zHUo$raycastapi.LaunchType).Background) (0, $6c9bb2e572dea89d$export$80e5033e369189f3)(error, {
                title: "Cannot query the data"
            });
        }
    }, [
        latestOptions
    ]);
    const fn = (0, $8zHUo$react.useMemo)(()=>{
        if (!(0, $8zHUo$nodefs.existsSync)(databasePath)) throw new Error("The database does not exist");
        return async (databasePath, query)=>{
            const abortSignal = abortable.current?.signal;
            return (0, $832d6ad39638ce0c$export$4cff4f142f384da7)(databasePath, query, {
                signal: abortSignal
            });
        };
    }, [
        databasePath
    ]);
    return {
        ...(0, $1f5338676d90e7a6$export$dd6b79aaabe7bc37)(fn, [
            databasePath,
            query
        ], {
            ...usePromiseOptions,
            onError: handleError
        }),
        permissionView: permissionView
    };
}
function $908f00f283581e25$var$PermissionErrorScreen(props) {
    const macosVenturaAndLater = parseInt((0, ($parcel$interopDefault($8zHUo$nodeos))).release().split(".")[0]) >= 22;
    const preferencesString = macosVenturaAndLater ? "Settings" : "Preferences";
    const action = macosVenturaAndLater ? {
        title: "Open System Settings -> Privacy",
        target: "x-apple.systempreferences:com.apple.preference.security?Privacy_AllFiles"
    } : {
        title: "Open System Preferences -> Security",
        target: "x-apple.systempreferences:com.apple.preference.security?Privacy_AllFiles"
    };
    if ((0, $8zHUo$raycastapi.environment).commandMode === "menu-bar") return /*#__PURE__*/ (0, $8zHUo$reactjsxruntime.jsxs)((0, $8zHUo$raycastapi.MenuBarExtra), {
        icon: (0, $8zHUo$raycastapi.Icon).Warning,
        title: (0, $8zHUo$raycastapi.environment).commandName,
        children: [
            /*#__PURE__*/ (0, $8zHUo$reactjsxruntime.jsx)((0, $8zHUo$raycastapi.MenuBarExtra).Item, {
                title: "Raycast needs full disk access",
                tooltip: `You can revert this access in ${preferencesString} whenever you want`
            }),
            props.priming ? /*#__PURE__*/ (0, $8zHUo$reactjsxruntime.jsx)((0, $8zHUo$raycastapi.MenuBarExtra).Item, {
                title: props.priming,
                tooltip: `You can revert this access in ${preferencesString} whenever you want`
            }) : null,
            /*#__PURE__*/ (0, $8zHUo$reactjsxruntime.jsx)((0, $8zHUo$raycastapi.MenuBarExtra).Separator, {}),
            /*#__PURE__*/ (0, $8zHUo$reactjsxruntime.jsx)((0, $8zHUo$raycastapi.MenuBarExtra).Item, {
                title: action.title,
                onAction: ()=>(0, $8zHUo$raycastapi.open)(action.target)
            })
        ]
    });
    return /*#__PURE__*/ (0, $8zHUo$reactjsxruntime.jsx)((0, $8zHUo$raycastapi.List), {
        children: /*#__PURE__*/ (0, $8zHUo$reactjsxruntime.jsx)((0, $8zHUo$raycastapi.List).EmptyView, {
            icon: {
                source: {
                    light: "https://raycast.com/uploads/extensions-utils-security-permissions-light.png",
                    dark: "https://raycast.com/uploads/extensions-utils-security-permissions-dark.png"
                }
            },
            title: "Raycast needs full disk access.",
            description: `${props.priming ? props.priming + "\n" : ""}You can revert this access in ${preferencesString} whenever you want.`,
            actions: /*#__PURE__*/ (0, $8zHUo$reactjsxruntime.jsx)((0, $8zHUo$raycastapi.ActionPanel), {
                children: /*#__PURE__*/ (0, $8zHUo$reactjsxruntime.jsx)((0, $8zHUo$raycastapi.Action).Open, {
                    ...action
                })
            })
        })
    });
}




var $c950f3189e9100ee$export$cd58ffd7e3880e66 = /*#__PURE__*/ function(FormValidation) {
    /** Show an error when the value of the item is empty */ FormValidation["Required"] = "required";
    return FormValidation;
}({});
function $c950f3189e9100ee$var$validationError(validation, value) {
    if (validation) {
        if (typeof validation === "function") return validation(value);
        else if (validation === "required") {
            let valueIsValid = typeof value !== "undefined" && value !== null;
            if (valueIsValid) switch(typeof value){
                case "string":
                    valueIsValid = value.length > 0;
                    break;
                case "object":
                    if (Array.isArray(value)) valueIsValid = value.length > 0;
                    else if (value instanceof Date) valueIsValid = value.getTime() > 0;
                    break;
                default:
                    break;
            }
            if (!valueIsValid) return "The item is required";
        }
    }
}
function $c950f3189e9100ee$export$87c0cf8eb5a167e0(props) {
    const { onSubmit: _onSubmit, validation: validation, initialValues: initialValues = {} } = props;
    // @ts-expect-error it's fine if we don't specify all the values
    const [values, setValues] = (0, $8zHUo$react.useState)(initialValues);
    const [errors, setErrors] = (0, $8zHUo$react.useState)({});
    const refs = (0, $8zHUo$react.useRef)({});
    const latestValidation = (0, $07a180af23fbf38b$export$d4b699e2c1148419)(validation || {});
    const latestOnSubmit = (0, $07a180af23fbf38b$export$d4b699e2c1148419)(_onSubmit);
    const focus = (0, $8zHUo$react.useCallback)((id)=>{
        refs.current[id]?.focus();
    }, [
        refs
    ]);
    const handleSubmit = (0, $8zHUo$react.useCallback)(async (values)=>{
        let validationErrors = false;
        for (const [id, validation] of Object.entries(latestValidation.current)){
            const error = $c950f3189e9100ee$var$validationError(validation, values[id]);
            if (error) {
                if (!validationErrors) {
                    validationErrors = {};
                    // we focus the first item that has an error
                    focus(id);
                }
                validationErrors[id] = error;
            }
        }
        if (validationErrors) {
            setErrors(validationErrors);
            return false;
        }
        const result = await latestOnSubmit.current(values);
        return typeof result === "boolean" ? result : true;
    }, [
        latestValidation,
        latestOnSubmit,
        focus
    ]);
    const setValidationError = (0, $8zHUo$react.useCallback)((id, error)=>{
        setErrors((errors)=>({
                ...errors,
                [id]: error
            }));
    }, [
        setErrors
    ]);
    const setValue = (0, $8zHUo$react.useCallback)(function(id, value) {
        // @ts-expect-error TS is always confused about SetStateAction, but it's fine here
        setValues((values)=>({
                ...values,
                [id]: typeof value === "function" ? value(values[id]) : value
            }));
    }, [
        setValues
    ]);
    const itemProps = (0, $8zHUo$react.useMemo)(()=>{
        // we have to use a proxy because we don't actually have any object to iterate through
        // so instead we dynamically create the props when required
        return new Proxy(// @ts-expect-error the whole point of a proxy...
        {}, {
            get (target, id) {
                const validation = latestValidation.current[id];
                const value = values[id];
                return {
                    onChange (value) {
                        if (errors[id]) {
                            const error = $c950f3189e9100ee$var$validationError(validation, value);
                            if (!error) setValidationError(id, undefined);
                        }
                        setValue(id, value);
                    },
                    onBlur (event) {
                        const error = $c950f3189e9100ee$var$validationError(validation, event.target.value);
                        if (error) setValidationError(id, error);
                    },
                    error: errors[id],
                    id: id,
                    // we shouldn't return `undefined` otherwise it will be an uncontrolled component
                    value: typeof value === "undefined" ? null : value,
                    ref: (instance)=>{
                        refs.current[id] = instance;
                    }
                };
            }
        });
    }, [
        errors,
        latestValidation,
        setValidationError,
        values,
        refs,
        setValue
    ]);
    const reset = (0, $8zHUo$react.useCallback)((values)=>{
        setErrors({});
        Object.entries(refs.current).forEach(([id, ref])=>{
            if (!values?.[id]) ref?.reset();
        });
        if (values) // @ts-expect-error it's fine if we don't specify all the values
        setValues(values);
    }, [
        setValues,
        setErrors,
        refs
    ]);
    return {
        handleSubmit: handleSubmit,
        setValidationError: setValidationError,
        setValue: setValue,
        values: values,
        itemProps: itemProps,
        focus: focus,
        reset: reset
    };
}





function $c3d9e48f722f6b4c$export$835fc3bd312a97c(prompt, options = {}) {
    const { creativity: creativity, stream: stream, model: model, ...usePromiseOptions } = options;
    const [data, setData] = (0, $8zHUo$react.useState)("");
    const abortable = (0, $8zHUo$react.useRef)(null);
    const { isLoading: isLoading, error: error, revalidate: revalidate } = (0, $1f5338676d90e7a6$export$dd6b79aaabe7bc37)(async (prompt, creativity, shouldStream)=>{
        setData("");
        const stream = (0, $8zHUo$raycastapi.AI).ask(prompt, {
            creativity: creativity,
            model: model,
            signal: abortable.current?.signal
        });
        if (shouldStream === false) setData(await stream);
        else {
            stream.on("data", (data)=>{
                setData((x)=>x + data);
            });
            await stream;
        }
    }, [
        prompt,
        creativity,
        stream
    ], {
        ...usePromiseOptions,
        abortable: abortable
    });
    return {
        isLoading: isLoading,
        data: data,
        error: error,
        revalidate: revalidate
    };
}





const $488f69277de5b02c$var$HALF_LIFE_DAYS = 10;
const $488f69277de5b02c$var$MS_PER_DAY = 86400000;
const $488f69277de5b02c$var$VISIT_TYPE_POINTS = {
    Default: 100,
    Embed: 0,
    Bookmark: 140
};
function $488f69277de5b02c$var$getNewFrecency(item) {
    const now = Date.now();
    const lastVisited = item ? item.lastVisited : 0;
    const frecency = item ? item.frecency : 0;
    const visitAgeInDays = (now - lastVisited) / $488f69277de5b02c$var$MS_PER_DAY;
    const DECAY_RATE_CONSTANT = Math.log(2) / ($488f69277de5b02c$var$HALF_LIFE_DAYS * $488f69277de5b02c$var$MS_PER_DAY);
    const currentVisitValue = $488f69277de5b02c$var$VISIT_TYPE_POINTS.Default * Math.exp(-DECAY_RATE_CONSTANT * visitAgeInDays);
    const totalVisitValue = frecency + currentVisitValue;
    return {
        lastVisited: now,
        frecency: totalVisitValue
    };
}
// eslint-disable-next-line @typescript-eslint/no-explicit-any
const $488f69277de5b02c$var$defaultKey = (item)=>{
    if (process.env.NODE_ENV !== "production" && (typeof item !== "object" || !item || !("id" in item) || typeof item.id != "string")) throw new Error("Specify a key function or make sure your items have an 'id' property");
    return item.id;
};
function $488f69277de5b02c$export$5f452da9662a701d(data, options) {
    const keyRef = (0, $07a180af23fbf38b$export$d4b699e2c1148419)(options?.key || $488f69277de5b02c$var$defaultKey);
    const sortUnvisitedRef = (0, $07a180af23fbf38b$export$d4b699e2c1148419)(options?.sortUnvisited);
    const [storedFrecencies, setStoredFrecencies] = (0, $4edf56917e12e612$export$14afb9e4c16377d3)(`raycast_frecency_${options?.namespace}`, {});
    const visitItem = (0, $8zHUo$react.useCallback)(async function updateFrecency(item) {
        const itemKey = keyRef.current(item);
        setStoredFrecencies((storedFrecencies)=>{
            const frecency = storedFrecencies[itemKey];
            const newFrecency = $488f69277de5b02c$var$getNewFrecency(frecency);
            return {
                ...storedFrecencies,
                [itemKey]: newFrecency
            };
        });
    }, [
        keyRef,
        setStoredFrecencies
    ]);
    const resetRanking = (0, $8zHUo$react.useCallback)(async function removeFrecency(item) {
        const itemKey = keyRef.current(item);
        setStoredFrecencies((storedFrecencies)=>{
            const newFrencencies = {
                ...storedFrecencies
            };
            delete newFrencencies[itemKey];
            return newFrencencies;
        });
    }, [
        keyRef,
        setStoredFrecencies
    ]);
    const sortedData = (0, $8zHUo$react.useMemo)(()=>{
        if (!data) return [];
        return data.sort((a, b)=>{
            const frecencyA = storedFrecencies[keyRef.current(a)];
            const frecencyB = storedFrecencies[keyRef.current(b)];
            // If a has a frecency, but b doesn't, a should come first
            if (frecencyA && !frecencyB) return -1;
            // If b has a frecency, but a doesn't, b should come first
            if (!frecencyA && frecencyB) return 1;
            // If both frecencies are defined,put the one with the higher frecency first
            if (frecencyA && frecencyB) return frecencyB.frecency - frecencyA.frecency;
            // If both frecencies are undefined, keep the original order
            return sortUnvisitedRef.current ? sortUnvisitedRef.current(a, b) : 0;
        });
    }, [
        storedFrecencies,
        data,
        keyRef,
        sortUnvisitedRef
    ]);
    return {
        data: sortedData,
        visitItem: visitItem,
        resetRanking: resetRanking
    };
}






function $8a703970ad0447b0$export$86e2cef2561044ac(key, initialValue) {
    const { data: value, isLoading: isLoading, mutate: mutate } = (0, $1f5338676d90e7a6$export$dd6b79aaabe7bc37)(async (storageKey)=>{
        const item = await (0, $8zHUo$raycastapi.LocalStorage).getItem(storageKey);
        return typeof item !== "undefined" ? JSON.parse(item, (0, $dfecd32049fa58e9$export$63698c10df99509c)) : initialValue;
    }, [
        key
    ]);
    async function setValue(value) {
        try {
            await mutate((0, $8zHUo$raycastapi.LocalStorage).setItem(key, JSON.stringify(value, (0, $dfecd32049fa58e9$export$b644b65666fe0c18))), {
                optimisticUpdate (value) {
                    return value;
                }
            });
        } catch (error) {
            await (0, $6c9bb2e572dea89d$export$80e5033e369189f3)(error, {
                title: "Failed to set value in local storage"
            });
        }
    }
    async function removeValue() {
        try {
            await mutate((0, $8zHUo$raycastapi.LocalStorage).removeItem(key), {
                optimisticUpdate () {
                    return undefined;
                }
            });
        } catch (error) {
            await (0, $6c9bb2e572dea89d$export$80e5033e369189f3)(error, {
                title: "Failed to remove value from local storage"
            });
        }
    }
    return {
        value: value,
        setValue: setValue,
        removeValue: removeValue,
        isLoading: isLoading
    };
}


function $6e284e59c85351de$var$hexToRGB(hex) {
    let r = 0;
    let g = 0;
    let b = 0;
    // 3 digits
    if (hex.length === 4) {
        r = parseInt(`${hex[1]}${hex[1]}`, 16);
        g = parseInt(`${hex[2]}${hex[2]}`, 16);
        b = parseInt(`${hex[3]}${hex[3]}`, 16);
    // 6 digits
    } else if (hex.length === 7) {
        r = parseInt(`${hex[1]}${hex[2]}`, 16);
        g = parseInt(`${hex[3]}${hex[4]}`, 16);
        b = parseInt(`${hex[5]}${hex[6]}`, 16);
    } else throw new Error(`Malformed hex color: ${hex}`);
    return {
        r: r,
        g: g,
        b: b
    };
}
function $6e284e59c85351de$var$rgbToHex({ r: r, g: g, b: b }) {
    let rString = r.toString(16);
    let gString = g.toString(16);
    let bString = b.toString(16);
    if (rString.length === 1) rString = `0${rString}`;
    if (gString.length === 1) gString = `0${gString}`;
    if (bString.length === 1) bString = `0${bString}`;
    return `#${rString}${gString}${bString}`;
}
function $6e284e59c85351de$var$rgbToHSL({ r: r, g: g, b: b }) {
    // Make r, g, and b fractions of 1
    r /= 255;
    g /= 255;
    b /= 255;
    // Find greatest and smallest channel values
    const cmin = Math.min(r, g, b);
    const cmax = Math.max(r, g, b);
    const delta = cmax - cmin;
    let h = 0;
    let s = 0;
    let l = 0;
    // Calculate hue
    // No difference
    if (delta === 0) h = 0;
    else if (cmax === r) h = (g - b) / delta % 6;
    else if (cmax === g) h = (b - r) / delta + 2;
    else h = (r - g) / delta + 4;
    h = Math.round(h * 60);
    // Make negative hues positive behind 360°
    if (h < 0) h += 360;
    // Calculate lightness
    l = (cmax + cmin) / 2;
    // Calculate saturation
    s = delta === 0 ? 0 : delta / (1 - Math.abs(2 * l - 1));
    // Multiply l and s by 100
    s = +(s * 100).toFixed(1);
    l = +(l * 100).toFixed(1);
    return {
        h: h,
        s: s,
        l: l
    };
}
function $6e284e59c85351de$var$hslToRGB({ h: h, s: s, l: l }) {
    // Must be fractions of 1
    s /= 100;
    l /= 100;
    const c = (1 - Math.abs(2 * l - 1)) * s;
    const x = c * (1 - Math.abs(h / 60 % 2 - 1));
    const m = l - c / 2;
    let r = 0;
    let g = 0;
    let b = 0;
    if (h >= 0 && h < 60) {
        r = c;
        g = x;
        b = 0;
    } else if (h >= 60 && h < 120) {
        r = x;
        g = c;
        b = 0;
    } else if (h >= 120 && h < 180) {
        r = 0;
        g = c;
        b = x;
    } else if (h >= 180 && h < 240) {
        r = 0;
        g = x;
        b = c;
    } else if (h >= 240 && h < 300) {
        r = x;
        g = 0;
        b = c;
    } else if (h >= 300 && h < 360) {
        r = c;
        g = 0;
        b = x;
    }
    r = Math.round((r + m) * 255);
    g = Math.round((g + m) * 255);
    b = Math.round((b + m) * 255);
    return {
        r: r,
        g: g,
        b: b
    };
}
function $6e284e59c85351de$var$hexToHSL(hex) {
    return $6e284e59c85351de$var$rgbToHSL($6e284e59c85351de$var$hexToRGB(hex));
}
function $6e284e59c85351de$var$hslToHex(hsl) {
    return $6e284e59c85351de$var$rgbToHex($6e284e59c85351de$var$hslToRGB(hsl));
}
function $6e284e59c85351de$var$clamp(value, min, max) {
    return min < max ? value < min ? min : value > max ? max : value : value < max ? max : value > min ? min : value;
}
const $6e284e59c85351de$var$offset = 12;
function $6e284e59c85351de$export$98ff09ca20bf2fe1(hex) {
    const hsl = $6e284e59c85351de$var$hexToHSL(hex);
    return $6e284e59c85351de$var$hslToHex({
        h: hsl.h,
        s: hsl.s,
        l: $6e284e59c85351de$var$clamp(hsl.l - $6e284e59c85351de$var$offset, 0, 100)
    });
}
function $6e284e59c85351de$export$31cf9e737f626ef1(hex) {
    const hsl = $6e284e59c85351de$var$hexToHSL(hex);
    return $6e284e59c85351de$var$hslToHex({
        h: hsl.h,
        s: hsl.s,
        l: $6e284e59c85351de$var$clamp(hsl.l + $6e284e59c85351de$var$offset, 0, 100)
    });
}


function $31a0ba4a4e2328d9$var$getWholeCharAndI(str, i) {
    const code = str.charCodeAt(i);
    if (Number.isNaN(code)) return [
        "",
        i
    ];
    if (code < 0xd800 || code > 0xdfff) return [
        str.charAt(i),
        i
    ]; // Normal character, keeping 'i' the same
    // High surrogate (could change last hex to 0xDB7F to treat high private
    // surrogates as single characters)
    if (0xd800 <= code && code <= 0xdbff) {
        if (str.length <= i + 1) throw new Error("High surrogate without following low surrogate");
        const next = str.charCodeAt(i + 1);
        if (0xdc00 > next || next > 0xdfff) throw new Error("High surrogate without following low surrogate");
        return [
            str.charAt(i) + str.charAt(i + 1),
            i + 1
        ];
    }
    // Low surrogate (0xDC00 <= code && code <= 0xDFFF)
    if (i === 0) throw new Error("Low surrogate without preceding high surrogate");
    const prev = str.charCodeAt(i - 1);
    // (could change last hex to 0xDB7F to treat high private surrogates
    // as single characters)
    if (0xd800 > prev || prev > 0xdbff) throw new Error("Low surrogate without preceding high surrogate");
    // Return the next character instead (and increment)
    return [
        str.charAt(i + 1),
        i + 1
    ];
}
const $31a0ba4a4e2328d9$var$avatarColorSet = [
    "#DC829A",
    "#D64854",
    "#D47600",
    "#D36CDD",
    "#52A9E4",
    "#7871E8",
    "#70920F",
    "#43B93A",
    "#EB6B3E",
    "#26B795",
    "#D85A9B",
    "#A067DC",
    "#BD9500",
    "#5385D9"
];
function $31a0ba4a4e2328d9$export$378f247c814d3cc9(name, options) {
    const words = name.trim().split(" ");
    let initials;
    if (words.length == 1 && $31a0ba4a4e2328d9$var$getWholeCharAndI(words[0], 0)[0]) initials = $31a0ba4a4e2328d9$var$getWholeCharAndI(words[0], 0)[0];
    else if (words.length > 1) {
        const firstWordFirstLetter = $31a0ba4a4e2328d9$var$getWholeCharAndI(words[0], 0)[0] || "";
        const lastWordFirstLetter = $31a0ba4a4e2328d9$var$getWholeCharAndI(words[words.length - 1], 0)[0] ?? "";
        initials = firstWordFirstLetter + lastWordFirstLetter;
    } else initials = "";
    let backgroundColor;
    if (options?.background) backgroundColor = options?.background;
    else {
        let initialsCharIndex = 0;
        let [char, i] = $31a0ba4a4e2328d9$var$getWholeCharAndI(initials, 0);
        while(char){
            initialsCharIndex += char.charCodeAt(0);
            [char, i] = $31a0ba4a4e2328d9$var$getWholeCharAndI(initials, i + 1);
        }
        const colorIndex = initialsCharIndex % $31a0ba4a4e2328d9$var$avatarColorSet.length;
        backgroundColor = $31a0ba4a4e2328d9$var$avatarColorSet[colorIndex];
    }
    const padding = 0;
    const radius = 50 - padding;
    const svg = `<svg xmlns="http://www.w3.org/2000/svg" width="100px" height="100px">
  ${options?.gradient !== false ? `<defs>
      <linearGradient id="Gradient" x1="0.25" x2="0.75" y1="0" y2="1">
        <stop offset="0%" stop-color="${(0, $6e284e59c85351de$export$31cf9e737f626ef1)(backgroundColor)}"/>
        <stop offset="50%" stop-color="${backgroundColor}"/>
        <stop offset="100%" stop-color="${(0, $6e284e59c85351de$export$98ff09ca20bf2fe1)(backgroundColor)}"/>
      </linearGradient>
  </defs>` : ""}
      <circle cx="50" cy="50" r="${radius}" fill="${options?.gradient !== false ? "url(#Gradient)" : backgroundColor}" />
      ${initials ? `<text x="50" y="80" font-size="${radius - 1}" font-family="Inter, sans-serif" text-anchor="middle" fill="white">${initials.toUpperCase()}</text>` : ""}
    </svg>
  `.replaceAll("\n", "");
    return `data:image/svg+xml,${encodeURIComponent(svg)}`;
}




function $5ea808515394f474$export$30c2a0095db95d06(url, options) {
    try {
        // a func adding https:// to the URL
        // for cases where the URL is not a full URL
        // e.g. "raycast.com"
        const sanitize = (url)=>{
            if (!url.startsWith("http")) return `https://${url}`;
            return url;
        };
        const urlObj = typeof url === "string" ? new (0, $8zHUo$nodeurl.URL)(sanitize(url)) : url;
        const hostname = urlObj.hostname;
        const faviconProvider = process.env.FAVICON_PROVIDER ?? "raycast";
        switch(faviconProvider){
            case "none":
                return {
                    source: options?.fallback ?? (0, $8zHUo$raycastapi.Icon).Link,
                    mask: options?.mask
                };
            case "apple":
                // we can't support apple favicons as it's a native API
                return {
                    source: options?.fallback ?? (0, $8zHUo$raycastapi.Icon).Link,
                    mask: options?.mask
                };
            case "duckduckgo":
            case "duckDuckGo":
                return {
                    source: `https://icons.duckduckgo.com/ip3/${hostname}.ico`,
                    fallback: options?.fallback ?? (0, $8zHUo$raycastapi.Icon).Link,
                    mask: options?.mask
                };
            case "google":
                return {
                    source: `https://www.google.com/s2/favicons?sz=${options?.size ?? 64}&domain=${hostname}`,
                    fallback: options?.fallback ?? (0, $8zHUo$raycastapi.Icon).Link,
                    mask: options?.mask
                };
            case "legacy":
            case "raycast":
            default:
                return {
                    source: `https://api.ray.so/favicon?url=${hostname}&size=${options?.size ?? 64}`,
                    fallback: options?.fallback ?? (0, $8zHUo$raycastapi.Icon).Link,
                    mask: options?.mask
                };
        }
    } catch (e) {
        console.error(e);
        return (0, $8zHUo$raycastapi.Icon).Link;
    }
}



function $a7897b4ca3fd078f$var$polarToCartesian(centerX, centerY, radius, angleInDegrees) {
    const angleInRadians = (angleInDegrees - 90) * Math.PI / 180.0;
    return {
        x: centerX + radius * Math.cos(angleInRadians),
        y: centerY + radius * Math.sin(angleInRadians)
    };
}
function $a7897b4ca3fd078f$var$describeArc(x, y, radius, startAngle, endAngle) {
    const start = $a7897b4ca3fd078f$var$polarToCartesian(x, y, radius, endAngle);
    const end = $a7897b4ca3fd078f$var$polarToCartesian(x, y, radius, startAngle);
    const largeArcFlag = endAngle - startAngle <= 180 ? "0" : "1";
    const d = [
        "M",
        start.x,
        start.y,
        "A",
        radius,
        radius,
        0,
        largeArcFlag,
        0,
        end.x,
        end.y
    ].join(" ");
    return d;
}
function $a7897b4ca3fd078f$export$e7138cfc4fbdc77c(progress, color = (0, $8zHUo$raycastapi.Color).Red, options) {
    const background = options?.background || ((0, $8zHUo$raycastapi.environment).appearance === "light" ? "black" : "white");
    const backgroundOpacity = options?.backgroundOpacity || 0.1;
    const stroke = 10;
    const padding = 5;
    const radius = 50 - padding - stroke / 2;
    const svg = `<svg xmlns="http://www.w3.org/2000/svg" width="100px" height="100px">
      <circle cx="50" cy="50" r="${radius}" stroke-width="${stroke}" stroke="${progress < 1 ? background : color}" opacity="${progress < 1 ? backgroundOpacity : "1"}" fill="none" />
      ${progress > 0 && progress < 1 ? `<path d="${$a7897b4ca3fd078f$var$describeArc(50, 50, radius, 0, progress * 360)}" stroke="${color}" stroke-width="${stroke}" fill="none" />` : ""}
    </svg>
  `.replaceAll("\n", "");
    return `data:image/svg+xml,${encodeURIComponent(svg)}`;
}





const $0307c646c5d03ba6$export$f9b82956c86fe8e0 = {
    asana: "1191201745684312",
    github: "7235fe8d42157f1f38c0",
    linear: "c8ff37b9225c3c9aefd7d66ea0e5b6f1",
    slack: "851756884692.5546927290212"
};


class $bd2f41db5e016369$export$905bf243392675e9 {
    constructor(options){
        this.clientId = options.clientId;
        this.scope = Array.isArray(options.scope) ? options.scope.join(" ") : options.scope;
        this.personalAccessToken = options.personalAccessToken;
        this.bodyEncoding = options.bodyEncoding;
        this.client = options.client;
        this.extraParameters = options.extraParameters;
        this.authorizeUrl = options.authorizeUrl;
        this.tokenUrl = options.tokenUrl;
        this.refreshTokenUrl = options.refreshTokenUrl;
        this.onAuthorize = options.onAuthorize;
        this.tokenResponseParser = options.tokenResponseParser ?? ((x)=>x);
        this.tokenRefreshResponseParser = options.tokenRefreshResponseParser ?? ((x)=>x);
        this.authorize = this.authorize.bind(this);
    }
    /**
   * Asana OAuth service provided out of the box.
   *
   * @example
   * ```typescript
   * const asana = OAuthService.asana({ scope: 'default' })
   * ```
   */ static asana(options) {
        return new $bd2f41db5e016369$export$905bf243392675e9({
            client: new (0, $8zHUo$raycastapi.OAuth).PKCEClient({
                redirectMethod: (0, $8zHUo$raycastapi.OAuth).RedirectMethod.Web,
                providerName: "Asana",
                providerIcon: `data:image/svg+xml,${encodeURIComponent(`<svg xmlns="http://www.w3.org/2000/svg" width="251" height="232" fill="none"><path fill="#F06A6A" d="M179.383 54.373c0 30.017-24.337 54.374-54.354 54.374-30.035 0-54.373-24.338-54.373-54.374C70.656 24.338 94.993 0 125.029 0c30.017 0 54.354 24.338 54.354 54.373ZM54.393 122.33C24.376 122.33.02 146.668.02 176.685c0 30.017 24.337 54.373 54.373 54.373 30.035 0 54.373-24.338 54.373-54.373 0-30.017-24.338-54.355-54.373-54.355Zm141.253 0c-30.035 0-54.373 24.338-54.373 54.374 0 30.035 24.338 54.373 54.373 54.373 30.017 0 54.374-24.338 54.374-54.373 0-30.036-24.338-54.374-54.374-54.374Z"/></svg>`)}`,
                providerId: "asana",
                description: "Connect your Asana account"
            }),
            clientId: options.clientId ?? (0, $0307c646c5d03ba6$export$f9b82956c86fe8e0).asana,
            authorizeUrl: options.authorizeUrl ?? "https://asana.oauth.raycast.com/authorize",
            tokenUrl: options.tokenUrl ?? "https://asana.oauth.raycast.com/token",
            refreshTokenUrl: options.refreshTokenUrl ?? "https://asana.oauth.raycast.com/refresh-token",
            scope: options.scope,
            personalAccessToken: options.personalAccessToken,
            onAuthorize: options.onAuthorize,
            bodyEncoding: options.bodyEncoding,
            tokenRefreshResponseParser: options.tokenRefreshResponseParser,
            tokenResponseParser: options.tokenResponseParser
        });
    }
    /**
   * GitHub OAuth service provided out of the box.
   *
   * @example
   * ```typescript
   * const github = OAuthService.github({ scope: 'repo user' })
   * ```
   */ static github(options) {
        return new $bd2f41db5e016369$export$905bf243392675e9({
            client: new (0, $8zHUo$raycastapi.OAuth).PKCEClient({
                redirectMethod: (0, $8zHUo$raycastapi.OAuth).RedirectMethod.Web,
                providerName: "GitHub",
                providerIcon: {
                    source: `data:image/svg+xml,${encodeURIComponent(`<svg xmlns="http://www.w3.org/2000/svg" width="64" height="64" viewBox="0 0 16 16"><path fill-rule="evenodd" d="M8 0C3.58 0 0 3.58 0 8c0 3.54 2.29 6.53 5.47 7.59.4.07.55-.17.55-.38 0-.19-.01-.82-.01-1.49-2.01.37-2.53-.49-2.69-.94-.09-.23-.48-.94-.82-1.13-.28-.15-.68-.52-.01-.53.63-.01 1.08.58 1.23.82.72 1.21 1.87.87 2.33.66.07-.52.28-.87.51-1.07-1.78-.2-3.64-.89-3.64-3.95 0-.87.31-1.59.82-2.15-.08-.2-.36-1.02.08-2.12 0 0 .67-.21 2.2.82.64-.18 1.32-.27 2-.27.68 0 1.36.09 2 .27 1.53-1.04 2.2-.82 2.2-.82.44 1.1.16 1.92.08 2.12.51.56.82 1.27.82 2.15 0 3.07-1.87 3.75-3.65 3.95.29.25.54.73.54 1.48 0 1.07-.01 1.93-.01 2.2 0 .21.15.46.55.38A8.013 8.013 0 0 0 16 8c0-4.42-3.58-8-8-8z"/></svg>`)}`,
                    tintColor: (0, $8zHUo$raycastapi.Color).PrimaryText
                },
                providerId: "github",
                description: "Connect your GitHub account"
            }),
            clientId: options.clientId ?? (0, $0307c646c5d03ba6$export$f9b82956c86fe8e0).github,
            authorizeUrl: options.authorizeUrl ?? "https://github.oauth.raycast.com/authorize",
            tokenUrl: options.tokenUrl ?? "https://github.oauth.raycast.com/token",
            refreshTokenUrl: options.refreshTokenUrl ?? "https://github.oauth.raycast.com/refresh-token",
            scope: options.scope,
            personalAccessToken: options.personalAccessToken,
            onAuthorize: options.onAuthorize,
            bodyEncoding: options.bodyEncoding,
            tokenRefreshResponseParser: options.tokenRefreshResponseParser,
            tokenResponseParser: options.tokenResponseParser
        });
    }
    /**
   * Google OAuth service provided out of the box.
   *
   * @example
   * ```typescript
   * const google = OAuthService.google({
   *   clientId: 'custom-client-id',
   *   authorizeUrl: 'https://accounts.google.com/o/oauth2/v2/auth',
   *   tokenUrl: 'https://oauth2.googleapis.com/token',
   *   scope: 'https://www.googleapis.com/auth/drive.readonly',
   * });
   * ```
   */ static google(options) {
        return new $bd2f41db5e016369$export$905bf243392675e9({
            client: new (0, $8zHUo$raycastapi.OAuth).PKCEClient({
                redirectMethod: (0, $8zHUo$raycastapi.OAuth).RedirectMethod.AppURI,
                providerName: "Google",
                providerIcon: `data:image/svg+xml,${encodeURIComponent(`<svg xmlns="http://www.w3.org/2000/svg" style="display:block" viewBox="0 0 48 48"><path fill="#EA4335" d="M24 9.5c3.54 0 6.71 1.22 9.21 3.6l6.85-6.85C35.9 2.38 30.47 0 24 0 14.62 0 6.51 5.38 2.56 13.22l7.98 6.19C12.43 13.72 17.74 9.5 24 9.5z"/><path fill="#4285F4" d="M46.98 24.55c0-1.57-.15-3.09-.38-4.55H24v9.02h12.94c-.58 2.96-2.26 5.48-4.78 7.18l7.73 6c4.51-4.18 7.09-10.36 7.09-17.65z"/><path fill="#FBBC05" d="M10.53 28.59c-.48-1.45-.76-2.99-.76-4.59s.27-3.14.76-4.59l-7.98-6.19C.92 16.46 0 20.12 0 24c0 3.88.92 7.54 2.56 10.78l7.97-6.19z"/><path fill="#34A853" d="M24 48c6.48 0 11.93-2.13 15.89-5.81l-7.73-6c-2.15 1.45-4.92 2.3-8.16 2.3-6.26 0-11.57-4.22-13.47-9.91l-7.98 6.19C6.51 42.62 14.62 48 24 48z"/><path fill="none" d="M0 0h48v48H0z"/></svg>`)}`,
                providerId: "google",
                description: "Connect your Google account"
            }),
            clientId: options.clientId,
            authorizeUrl: options.authorizeUrl ?? "https://accounts.google.com/o/oauth2/v2/auth",
            tokenUrl: options.tokenUrl ?? "https://oauth2.googleapis.com/token",
            refreshTokenUrl: options.tokenUrl,
            scope: options.scope,
            personalAccessToken: options.personalAccessToken,
            bodyEncoding: options.bodyEncoding ?? "url-encoded",
            onAuthorize: options.onAuthorize,
            tokenRefreshResponseParser: options.tokenRefreshResponseParser,
            tokenResponseParser: options.tokenResponseParser
        });
    }
    /**
   * Jira OAuth service provided out of the box.
   *
   * @example
   * ```typescript
   * const jira = OAuthService.jira({
   *   clientId: 'custom-client-id',
   *   authorizeUrl: 'https://auth.atlassian.com/authorize',
   *   tokenUrl: 'https://api.atlassian.com/oauth/token',
   *   scope: 'read:jira-user read:jira-work offline_access'
   * });
   * ```
   */ static jira(options) {
        return new $bd2f41db5e016369$export$905bf243392675e9({
            client: new (0, $8zHUo$raycastapi.OAuth).PKCEClient({
                redirectMethod: (0, $8zHUo$raycastapi.OAuth).RedirectMethod.Web,
                providerName: "Jira",
                providerIcon: `data:image/svg+xml,${encodeURIComponent(`<svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" width="2361" height="2500" viewBox="2.59 0 214.091 224"><linearGradient id="a" x1="102.4" x2="56.15" y1="218.63" y2="172.39" gradientTransform="matrix(1 0 0 -1 0 264)" gradientUnits="userSpaceOnUse"><stop offset=".18" stop-color="#0052cc"/><stop offset="1" stop-color="#2684ff"/></linearGradient><linearGradient xlink:href="#a" id="b" x1="114.65" x2="160.81" y1="85.77" y2="131.92"/><path fill="#2684ff" d="M214.06 105.73 117.67 9.34 108.33 0 35.77 72.56 2.59 105.73a8.89 8.89 0 0 0 0 12.54l66.29 66.29L108.33 224l72.55-72.56 1.13-1.12 32.05-32a8.87 8.87 0 0 0 0-12.59zm-105.73 39.39L75.21 112l33.12-33.12L141.44 112z"/><path fill="url(#a)" d="M108.33 78.88a55.75 55.75 0 0 1-.24-78.61L35.62 72.71l39.44 39.44z"/><path fill="url(#b)" d="m141.53 111.91-33.2 33.21a55.77 55.77 0 0 1 0 78.86L181 151.35z"/></svg>`)}`,
                providerId: "jira",
                description: "Connect your Jira account"
            }),
            clientId: options.clientId,
            authorizeUrl: options.authorizeUrl ?? "https://auth.atlassian.com/authorize",
            tokenUrl: options.tokenUrl ?? "https://auth.atlassian.com/oauth/token",
            refreshTokenUrl: options.refreshTokenUrl,
            scope: options.scope,
            personalAccessToken: options.personalAccessToken,
            onAuthorize: options.onAuthorize,
            bodyEncoding: options.bodyEncoding,
            tokenRefreshResponseParser: options.tokenRefreshResponseParser,
            tokenResponseParser: options.tokenResponseParser
        });
    }
    /**
   * Linear OAuth service provided out of the box.
   *
   * @example
   * ```typescript
   * const linear = OAuthService.linear({ scope: 'read write' })
   * ```
   */ static linear(options) {
        return new $bd2f41db5e016369$export$905bf243392675e9({
            client: new (0, $8zHUo$raycastapi.OAuth).PKCEClient({
                redirectMethod: (0, $8zHUo$raycastapi.OAuth).RedirectMethod.Web,
                providerName: "Linear",
                providerIcon: {
                    source: {
                        light: `data:image/svg+xml,${encodeURIComponent(`<svg xmlns="http://www.w3.org/2000/svg" fill="#222326" width="200" height="200" viewBox="0 0 100 100"><path d="M1.22541 61.5228c-.2225-.9485.90748-1.5459 1.59638-.857L39.3342 97.1782c.6889.6889.0915 1.8189-.857 1.5964C20.0515 94.4522 5.54779 79.9485 1.22541 61.5228ZM.00189135 46.8891c-.01764375.2833.08887215.5599.28957165.7606L52.3503 99.7085c.2007.2007.4773.3075.7606.2896 2.3692-.1476 4.6938-.46 6.9624-.9259.7645-.157 1.0301-1.0963.4782-1.6481L2.57595 39.4485c-.55186-.5519-1.49117-.2863-1.648174.4782-.465915 2.2686-.77832 4.5932-.92588465 6.9624ZM4.21093 29.7054c-.16649.3738-.08169.8106.20765 1.1l64.77602 64.776c.2894.2894.7262.3742 1.1.2077 1.7861-.7956 3.5171-1.6927 5.1855-2.684.5521-.328.6373-1.0867.1832-1.5407L8.43566 24.3367c-.45409-.4541-1.21271-.3689-1.54074.1832-.99132 1.6684-1.88843 3.3994-2.68399 5.1855ZM12.6587 18.074c-.3701-.3701-.393-.9637-.0443-1.3541C21.7795 6.45931 35.1114 0 49.9519 0 77.5927 0 100 22.4073 100 50.0481c0 14.8405-6.4593 28.1724-16.7199 37.3375-.3903.3487-.984.3258-1.3542-.0443L12.6587 18.074Z"/></svg>`)}`,
                        dark: `data:image/svg+xml,${encodeURIComponent(`<svg xmlns="http://www.w3.org/2000/svg" fill="#fff" width="200" height="200" viewBox="0 0 100 100"><path d="M1.22541 61.5228c-.2225-.9485.90748-1.5459 1.59638-.857L39.3342 97.1782c.6889.6889.0915 1.8189-.857 1.5964C20.0515 94.4522 5.54779 79.9485 1.22541 61.5228ZM.00189135 46.8891c-.01764375.2833.08887215.5599.28957165.7606L52.3503 99.7085c.2007.2007.4773.3075.7606.2896 2.3692-.1476 4.6938-.46 6.9624-.9259.7645-.157 1.0301-1.0963.4782-1.6481L2.57595 39.4485c-.55186-.5519-1.49117-.2863-1.648174.4782-.465915 2.2686-.77832 4.5932-.92588465 6.9624ZM4.21093 29.7054c-.16649.3738-.08169.8106.20765 1.1l64.77602 64.776c.2894.2894.7262.3742 1.1.2077 1.7861-.7956 3.5171-1.6927 5.1855-2.684.5521-.328.6373-1.0867.1832-1.5407L8.43566 24.3367c-.45409-.4541-1.21271-.3689-1.54074.1832-.99132 1.6684-1.88843 3.3994-2.68399 5.1855ZM12.6587 18.074c-.3701-.3701-.393-.9637-.0443-1.3541C21.7795 6.45931 35.1114 0 49.9519 0 77.5927 0 100 22.4073 100 50.0481c0 14.8405-6.4593 28.1724-16.7199 37.3375-.3903.3487-.984.3258-1.3542-.0443L12.6587 18.074Z" /></svg>`)}`
                    }
                },
                providerId: "linear",
                description: "Connect your Linear account"
            }),
            clientId: options.clientId ?? (0, $0307c646c5d03ba6$export$f9b82956c86fe8e0).linear,
            authorizeUrl: options.authorizeUrl ?? "https://linear.oauth.raycast.com/authorize",
            tokenUrl: options.tokenUrl ?? "https://linear.oauth.raycast.com/token",
            refreshTokenUrl: options.refreshTokenUrl ?? "https://linear.oauth.raycast.com/refresh-token",
            scope: options.scope,
            extraParameters: {
                actor: "user"
            },
            onAuthorize: options.onAuthorize,
            bodyEncoding: options.bodyEncoding,
            tokenRefreshResponseParser: options.tokenRefreshResponseParser,
            tokenResponseParser: options.tokenResponseParser
        });
    }
    /**
   * Slack OAuth service provided out of the box.
   *
   * @example
   * ```typescript
   * const slack = OAuthService.slack({ scope: 'emoji:read' })
   * ```
   */ static slack(options) {
        return new $bd2f41db5e016369$export$905bf243392675e9({
            client: new (0, $8zHUo$raycastapi.OAuth).PKCEClient({
                redirectMethod: (0, $8zHUo$raycastapi.OAuth).RedirectMethod.Web,
                providerName: "Slack",
                providerIcon: `data:image/svg+xml,${encodeURIComponent(`<svg xmlns="http://www.w3.org/2000/svg" viewBox="73 73 124 124"><style>.st0{fill:#e01e5a}.st1{fill:#36c5f0}.st2{fill:#2eb67d}.st3{fill:#ecb22e}</style><path d="M99.4 151.2c0 7.1-5.8 12.9-12.9 12.9-7.1 0-12.9-5.8-12.9-12.9 0-7.1 5.8-12.9 12.9-12.9h12.9v12.9zM105.9 151.2c0-7.1 5.8-12.9 12.9-12.9s12.9 5.8 12.9 12.9v32.3c0 7.1-5.8 12.9-12.9 12.9s-12.9-5.8-12.9-12.9v-32.3z" class="st0"/><path d="M118.8 99.4c-7.1 0-12.9-5.8-12.9-12.9 0-7.1 5.8-12.9 12.9-12.9s12.9 5.8 12.9 12.9v12.9h-12.9zM118.8 105.9c7.1 0 12.9 5.8 12.9 12.9s-5.8 12.9-12.9 12.9H86.5c-7.1 0-12.9-5.8-12.9-12.9s5.8-12.9 12.9-12.9h32.3z" class="st1"/><path d="M170.6 118.8c0-7.1 5.8-12.9 12.9-12.9 7.1 0 12.9 5.8 12.9 12.9s-5.8 12.9-12.9 12.9h-12.9v-12.9zM164.1 118.8c0 7.1-5.8 12.9-12.9 12.9-7.1 0-12.9-5.8-12.9-12.9V86.5c0-7.1 5.8-12.9 12.9-12.9 7.1 0 12.9 5.8 12.9 12.9v32.3z" class="st2"/><path d="M151.2 170.6c7.1 0 12.9 5.8 12.9 12.9 0 7.1-5.8 12.9-12.9 12.9-7.1 0-12.9-5.8-12.9-12.9v-12.9h12.9zM151.2 164.1c-7.1 0-12.9-5.8-12.9-12.9 0-7.1 5.8-12.9 12.9-12.9h32.3c7.1 0 12.9 5.8 12.9 12.9 0 7.1-5.8 12.9-12.9 12.9h-32.3z" class="st3"/></svg>`)}`,
                providerId: "slack",
                description: "Connect your Slack account"
            }),
            clientId: options.clientId ?? (0, $0307c646c5d03ba6$export$f9b82956c86fe8e0).slack,
            authorizeUrl: options.authorizeUrl ?? "https://slack.oauth.raycast.com/authorize",
            tokenUrl: options.tokenUrl ?? "https://slack.oauth.raycast.com/token",
            refreshTokenUrl: options.tokenUrl ?? "https://slack.oauth.raycast.com/refresh-token",
            scope: "",
            extraParameters: {
                user_scope: options.scope
            },
            personalAccessToken: options.personalAccessToken,
            bodyEncoding: options.tokenUrl ? options.bodyEncoding ?? "url-encoded" : "json",
            onAuthorize: options.onAuthorize,
            tokenRefreshResponseParser: options.tokenRefreshResponseParser,
            // eslint-disable-next-line @typescript-eslint/no-explicit-any
            tokenResponseParser: options.tokenResponseParser ?? ((response)=>{
                return {
                    access_token: response.authed_user.access_token,
                    scope: response.authed_user.scope
                };
            })
        });
    }
    /**
   * Zoom OAuth service provided out of the box.
   *
   * @example
   * ```typescript
   * const zoom = OAuthService.zoom({
   *   clientId: 'custom-client-id',
   *   authorizeUrl: 'https://zoom.us/oauth/authorize',
   *   tokenUrl: 'https://zoom.us/oauth/token',
   *   scope: 'meeting:write',
   *   personalAccessToken: 'personal-access-token',
   * });
   * ```
   */ static zoom(options) {
        return new $bd2f41db5e016369$export$905bf243392675e9({
            client: new (0, $8zHUo$raycastapi.OAuth).PKCEClient({
                redirectMethod: (0, $8zHUo$raycastapi.OAuth).RedirectMethod.Web,
                providerName: "Zoom",
                providerIcon: `data:image/svg+xml,${encodeURIComponent(`<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 351.845 80"><path d="M73.786 78.835H10.88A10.842 10.842 0 0 1 .833 72.122a10.841 10.841 0 0 1 2.357-11.85L46.764 16.7h-31.23C6.954 16.699 0 9.744 0 1.165h58.014c4.414 0 8.357 2.634 10.046 6.712a10.843 10.843 0 0 1-2.356 11.85L22.13 63.302h36.122c8.58 0 15.534 6.955 15.534 15.534Zm278.059-48.544C351.845 13.588 338.256 0 321.553 0c-8.934 0-16.975 3.89-22.524 10.063C293.48 3.89 285.44 0 276.505 0c-16.703 0-30.291 13.588-30.291 30.291v48.544c8.579 0 15.534-6.955 15.534-15.534v-33.01c0-8.137 6.62-14.757 14.757-14.757s14.757 6.62 14.757 14.757v33.01c0 8.58 6.955 15.534 15.534 15.534V30.291c0-8.137 6.62-14.757 14.757-14.757s14.758 6.62 14.758 14.757v33.01c0 8.58 6.954 15.534 15.534 15.534V30.291ZM238.447 40c0 22.091-17.909 40-40 40s-40-17.909-40-40 17.908-40 40-40 40 17.909 40 40Zm-15.534 0c0-13.512-10.954-24.466-24.466-24.466S173.98 26.488 173.98 40s10.953 24.466 24.466 24.466S222.913 53.512 222.913 40Zm-70.68 0c0 22.091-17.909 40-40 40s-40-17.909-40-40 17.909-40 40-40 40 17.909 40 40Zm-15.534 0c0-13.512-10.954-24.466-24.466-24.466S87.767 26.488 87.767 40s10.954 24.466 24.466 24.466S136.699 53.512 136.699 40Z" style="fill:#0b5cff"/></svg>`)}`,
                providerId: "zoom",
                description: "Connect your Zoom account"
            }),
            clientId: options.clientId,
            authorizeUrl: options.authorizeUrl ?? "https://zoom.us/oauth/authorize",
            tokenUrl: options.tokenUrl ?? "https://zoom.us/oauth/token",
            refreshTokenUrl: options.refreshTokenUrl,
            scope: options.scope,
            personalAccessToken: options.personalAccessToken,
            bodyEncoding: options.bodyEncoding ?? "url-encoded",
            onAuthorize: options.onAuthorize,
            tokenRefreshResponseParser: options.tokenRefreshResponseParser,
            tokenResponseParser: options.tokenResponseParser
        });
    }
    /**
   * Initiates the OAuth authorization process or refreshes existing tokens if necessary.
   * If the current token set has a refresh token and it is expired, then the function will refresh the tokens.
   * If no tokens exist, it will initiate the OAuth authorization process and fetch the tokens.
   *
   * @returns {Promise<string>} A promise that resolves with the access token obtained from the authorization flow, or null if the token could not be obtained.
   */ async authorize() {
        const currentTokenSet = await this.client.getTokens();
        if (currentTokenSet?.accessToken) {
            if (currentTokenSet.refreshToken && currentTokenSet.isExpired()) {
                const tokens = await this.refreshTokens({
                    token: currentTokenSet.refreshToken
                });
                // In the case where the refresh token flows fails, nothing is returned and the authorize function is called again.
                if (tokens) {
                    await this.client.setTokens(tokens);
                    return tokens.access_token;
                }
            }
            return currentTokenSet.accessToken;
        }
        const authRequest = await this.client.authorizationRequest({
            endpoint: this.authorizeUrl,
            clientId: this.clientId,
            scope: this.scope,
            extraParameters: this.extraParameters
        });
        const { authorizationCode: authorizationCode } = await this.client.authorize(authRequest);
        const tokens = await this.fetchTokens({
            authRequest: authRequest,
            authorizationCode: authorizationCode
        });
        await this.client.setTokens(tokens);
        return tokens.access_token;
    }
    async fetchTokens({ authRequest: authRequest, authorizationCode: authorizationCode }) {
        let options;
        if (this.bodyEncoding === "url-encoded") {
            const params = new URLSearchParams();
            params.append("client_id", this.clientId);
            params.append("code", authorizationCode);
            params.append("code_verifier", authRequest.codeVerifier);
            params.append("grant_type", "authorization_code");
            params.append("redirect_uri", authRequest.redirectURI);
            options = {
                body: params
            };
        } else options = {
            body: JSON.stringify({
                client_id: this.clientId,
                code: authorizationCode,
                code_verifier: authRequest.codeVerifier,
                grant_type: "authorization_code",
                redirect_uri: authRequest.redirectURI
            }),
            headers: {
                "Content-Type": "application/json"
            }
        };
        const response = await fetch(this.tokenUrl, {
            method: "POST",
            ...options
        });
        if (!response.ok) {
            const responseText = await response.text();
            console.error("fetch tokens error:", responseText);
            throw new Error(`Error while fetching tokens: ${response.status} (${response.statusText})\n${responseText}`);
        }
        const tokens = this.tokenResponseParser(await response.json());
        // Some clients such as Linear can return a scope array instead of a string
        return Array.isArray(tokens.scope) ? {
            ...tokens,
            scope: tokens.scope.join(" ")
        } : tokens;
    }
    async refreshTokens({ token: token }) {
        let options;
        if (this.bodyEncoding === "url-encoded") {
            const params = new URLSearchParams();
            params.append("client_id", this.clientId);
            params.append("refresh_token", token);
            params.append("grant_type", "refresh_token");
            options = {
                body: params
            };
        } else options = {
            body: JSON.stringify({
                client_id: this.clientId,
                refresh_token: token,
                grant_type: "refresh_token"
            }),
            headers: {
                "Content-Type": "application/json"
            }
        };
        const response = await fetch(this.refreshTokenUrl ?? this.tokenUrl, {
            method: "POST",
            ...options
        });
        if (!response.ok) {
            const responseText = await response.text();
            console.error("refresh tokens error:", responseText);
            // If the refresh token is invalid, stop the flow here, log out the user and prompt them to re-authorize.
            this.client.description = `${this.client.providerName} needs you to sign-in again. Press \u{23CE} or click the button below to continue.`;
            await this.client.removeTokens();
            await this.authorize();
        } else {
            const tokenResponse = this.tokenRefreshResponseParser(await response.json());
            tokenResponse.refresh_token = tokenResponse.refresh_token ?? token;
            return tokenResponse;
        }
    }
}





let $335119ff9d5923ac$var$token = null;
let $335119ff9d5923ac$var$type = null;
let $335119ff9d5923ac$var$authorize = null;
let $335119ff9d5923ac$var$getIdToken = null;
let $335119ff9d5923ac$var$onAuthorize = null;
function $335119ff9d5923ac$export$d6bc6f4110e73ed6(options) {
    if ((0, $8zHUo$raycastapi.environment).commandMode === "no-view") return (fn)=>{
        const noViewFn = async (props)=>{
            if (!$335119ff9d5923ac$var$token) {
                $335119ff9d5923ac$var$token = options.personalAccessToken ?? await options.authorize();
                $335119ff9d5923ac$var$type = options.personalAccessToken ? "personal" : "oauth";
                const idToken = (await options.client?.getTokens())?.idToken;
                if (options.onAuthorize) await Promise.resolve(options.onAuthorize({
                    token: $335119ff9d5923ac$var$token,
                    type: $335119ff9d5923ac$var$type,
                    idToken: idToken
                }));
            }
            return fn(props);
        };
        return noViewFn;
    };
    return (Component)=>{
        const WrappedComponent = (props)=>{
            if (options.personalAccessToken) {
                $335119ff9d5923ac$var$token = options.personalAccessToken;
                $335119ff9d5923ac$var$type = "personal";
            } else {
                if (!$335119ff9d5923ac$var$authorize) $335119ff9d5923ac$var$authorize = options.authorize();
                $335119ff9d5923ac$var$token = (0, ($parcel$interopDefault($8zHUo$react))).use($335119ff9d5923ac$var$authorize);
                $335119ff9d5923ac$var$type = "oauth";
            }
            let idToken;
            if (options.client) {
                if (!$335119ff9d5923ac$var$getIdToken) $335119ff9d5923ac$var$getIdToken = options.client?.getTokens().then((tokens)=>tokens?.idToken);
                idToken = (0, ($parcel$interopDefault($8zHUo$react))).use($335119ff9d5923ac$var$getIdToken);
            }
            if (options.onAuthorize) {
                if (!$335119ff9d5923ac$var$onAuthorize) $335119ff9d5923ac$var$onAuthorize = Promise.resolve(options.onAuthorize({
                    token: $335119ff9d5923ac$var$token,
                    type: $335119ff9d5923ac$var$type,
                    idToken: idToken
                }));
                (0, ($parcel$interopDefault($8zHUo$react))).use($335119ff9d5923ac$var$onAuthorize);
            }
            // eslint-disable-next-line @typescript-eslint/ban-ts-comment
            // @ts-ignore too complicated for TS
            return /*#__PURE__*/ (0, $8zHUo$reactjsxruntime.jsx)(Component, {
                ...props
            });
        };
        WrappedComponent.displayName = `withAccessToken(${Component.displayName || Component.name})`;
        return WrappedComponent;
    };
}
function $335119ff9d5923ac$export$84773cc9bf7dbe87() {
    if (!$335119ff9d5923ac$var$token || !$335119ff9d5923ac$var$type) throw new Error("getAccessToken must be used when authenticated (eg. used inside `withAccessToken`)");
    return {
        token: $335119ff9d5923ac$var$token,
        type: $335119ff9d5923ac$var$type
    };
}







var $7cabae6fedcce1d1$export$a7e8ed272ae8db08 = /*#__PURE__*/ function(DeeplinkType) {
    /** A script command */ DeeplinkType["ScriptCommand"] = "script-command";
    /** An extension command */ DeeplinkType["Extension"] = "extension";
    return DeeplinkType;
}({});
function $7cabae6fedcce1d1$var$getProtocol() {
    return (0, $8zHUo$raycastapi.environment).raycastVersion.includes("alpha") ? "raycastinternal://" : "raycast://";
}
function $7cabae6fedcce1d1$var$getOwnerOrAuthorName() {
    const packageJSON = JSON.parse((0, ($parcel$interopDefault($8zHUo$nodefs))).readFileSync((0, ($parcel$interopDefault($8zHUo$nodepath))).join((0, $8zHUo$raycastapi.environment).assetsPath, "..", "package.json"), "utf8"));
    return packageJSON.owner || packageJSON.author;
}
function $7cabae6fedcce1d1$export$f537f4c2068da401(options) {
    let url = `${$7cabae6fedcce1d1$var$getProtocol()}script-commands/${options.command}`;
    if (options.arguments) {
        let params = "";
        for (const arg of options.arguments)params += "&arguments=" + encodeURIComponent(arg);
        url += "?" + params.substring(1);
    }
    return url;
}
function $7cabae6fedcce1d1$export$ddb13afcb01cd60d(options) {
    let ownerOrAuthorName = $7cabae6fedcce1d1$var$getOwnerOrAuthorName();
    let extensionName = (0, $8zHUo$raycastapi.environment).extensionName;
    if ("ownerOrAuthorName" in options && "extensionName" in options) {
        ownerOrAuthorName = options.ownerOrAuthorName;
        extensionName = options.extensionName;
    }
    let url = `${$7cabae6fedcce1d1$var$getProtocol()}extensions/${ownerOrAuthorName}/${extensionName}/${options.command}`;
    let params = "";
    if (options.launchType) params += "&launchType=" + encodeURIComponent(options.launchType);
    if (options.arguments) params += "&arguments=" + encodeURIComponent(JSON.stringify(options.arguments));
    if (options.context) params += "&context=" + encodeURIComponent(JSON.stringify(options.context));
    if (options.fallbackText) params += "&fallbackText=" + encodeURIComponent(options.fallbackText);
    if (params) url += "?" + params.substring(1);
    return url;
}
function $7cabae6fedcce1d1$export$c4dc2df9fd7350e0(options) {
    if (options.type === "script-command") return $7cabae6fedcce1d1$export$f537f4c2068da401(options);
    else return $7cabae6fedcce1d1$export$ddb13afcb01cd60d(options);
}



function $d83a07cbe27ed7f3$export$71c177e77c592df2(databasePath, query) {
    return (0, $832d6ad39638ce0c$export$4cff4f142f384da7)(databasePath, query);
}




async function $ca034de50c750bbf$export$8982d27dc997624f(script, optionsOrArgs, options) {
    if (process.platform !== "darwin") throw new Error("AppleScript is only supported on macOS");
    const { humanReadableOutput: humanReadableOutput, language: language, timeout: timeout, ...execOptions } = Array.isArray(optionsOrArgs) ? options || {} : optionsOrArgs || {};
    const outputArguments = humanReadableOutput !== false ? [] : [
        "-ss"
    ];
    if (language === "JavaScript") outputArguments.push("-l", "JavaScript");
    if (Array.isArray(optionsOrArgs)) outputArguments.push("-", ...optionsOrArgs);
    const spawned = (0, ($parcel$interopDefault($8zHUo$nodechild_process))).spawn("osascript", outputArguments, {
        ...execOptions,
        env: {
            PATH: "/usr/local/bin:/usr/bin:/bin:/usr/sbin:/sbin"
        }
    });
    const spawnedPromise = (0, $abcdf0eb4757394f$export$6e3a9b5342d42997)(spawned, {
        timeout: timeout ?? 10000
    });
    spawned.stdin.end(script);
    const [{ error: error, exitCode: exitCode, signal: signal, timedOut: timedOut }, stdoutResult, stderrResult] = await (0, $abcdf0eb4757394f$export$67b768ac9e1c70fa)(spawned, {
        encoding: "utf8"
    }, spawnedPromise);
    const stdout = (0, $abcdf0eb4757394f$export$200978bbc0b73ca)({
        stripFinalNewline: true
    }, stdoutResult);
    const stderr = (0, $abcdf0eb4757394f$export$200978bbc0b73ca)({
        stripFinalNewline: true
    }, stderrResult);
    return (0, $abcdf0eb4757394f$export$a8f5efe603803b77)({
        stdout: stdout,
        stderr: stderr,
        error: error,
        exitCode: exitCode,
        signal: signal,
        timedOut: timedOut,
        command: "osascript",
        options: options,
        parentError: new Error()
    });
}




async function $d472c30fd9053885$export$fc36b0024b60e761(script, options) {
    if (process.platform !== "win32") throw new Error("PowerShell is only supported on Windows");
    const { timeout: timeout, ...execOptions } = options || {};
    const outputArguments = [
        "-NoLogo",
        "-NoProfile",
        "-NonInteractive",
        "-Command",
        "-"
    ];
    const spawned = (0, ($parcel$interopDefault($8zHUo$nodechild_process))).spawn("powershell.exe", outputArguments, {
        ...execOptions
    });
    const spawnedPromise = (0, $abcdf0eb4757394f$export$6e3a9b5342d42997)(spawned, {
        timeout: timeout ?? 10000
    });
    spawned.stdin.end(script);
    const [{ error: error, exitCode: exitCode, signal: signal, timedOut: timedOut }, stdoutResult, stderrResult] = await (0, $abcdf0eb4757394f$export$67b768ac9e1c70fa)(spawned, {
        encoding: "utf8"
    }, spawnedPromise);
    const stdout = (0, $abcdf0eb4757394f$export$200978bbc0b73ca)({
        stripFinalNewline: true
    }, stdoutResult);
    const stderr = (0, $abcdf0eb4757394f$export$200978bbc0b73ca)({
        stripFinalNewline: true
    }, stderrResult);
    return (0, $abcdf0eb4757394f$export$a8f5efe603803b77)({
        stdout: stdout,
        stderr: stderr,
        error: error,
        exitCode: exitCode,
        signal: signal,
        timedOut: timedOut,
        command: "powershell.exe",
        options: options,
        parentError: new Error()
    });
}





function $20660adb77b18d0d$export$33b32b3abf8170f0(fn, options) {
    const cache = new (0, $8zHUo$raycastapi.Cache)({
        namespace: (0, $dfecd32049fa58e9$export$d6af199866bfb566)(fn)
    });
    const wrappedFn = async (...args)=>{
        const key = (0, $dfecd32049fa58e9$export$d6af199866bfb566)(args || []) + options?.internal_cacheKeySuffix;
        const cached = cache.get(key);
        if (cached) {
            const { data: data, timestamp: timestamp } = JSON.parse(cached, (0, $dfecd32049fa58e9$export$63698c10df99509c));
            const isExpired = options?.maxAge && Date.now() - timestamp > options.maxAge;
            if (!isExpired && (!options?.validate || options.validate(data))) return data;
        }
        // eslint-disable-next-line @typescript-eslint/ban-ts-comment
        // @ts-ignore
        const result = await fn(...args);
        cache.set(key, JSON.stringify({
            data: result,
            timestamp: Date.now()
        }, (0, $dfecd32049fa58e9$export$b644b65666fe0c18)));
        return result;
    };
    wrappedFn.clearCache = ()=>{
        cache.clear();
    };
    // @ts-expect-error too complex for TS
    return wrappedFn;
}




//# sourceMappingURL=main.js.map
