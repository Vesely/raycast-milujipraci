import { Toast, Form, AI, Image, Color, OAuth, LaunchProps, LaunchType } from "@raycast/api";
import React, { RefObject, Dispatch, SetStateAction, JSX } from "react";
import { URL } from "node:url";
type PaginationOptions<T = any> = {
    /**
     * Specifies the current page index. Zero-based.
     */
    page: number;
    /**
     * The last item from the previous page of results, useful for APIs implementing cursor-based pagination.
     */
    lastItem?: Flatten<T>;
    /**
     * Some APIs don't use the last returned item as a cursor, but instead provide the next cursor explicitly. In those cases,
     * you can pass `cursor` along with `data` and `hasMore`, and it will be included in each pagination call.
     */
    cursor?: any;
};
type FunctionReturningPromise<T extends any[] = any[], U = any> = (...args: T) => Promise<U>;
type FunctionReturningPaginatedPromise<T extends any[] = any[], U extends any[] = any[]> = (...args: T) => (pagination: PaginationOptions<U>) => Promise<{
    data: U;
    hasMore?: boolean;
    cursor?: any;
}>;
type UnwrapReturn<T extends FunctionReturningPromise | FunctionReturningPaginatedPromise> = T extends FunctionReturningPromise ? Awaited<ReturnType<T>> : T extends FunctionReturningPaginatedPromise ? Awaited<ReturnType<ReturnType<T>>>["data"] : never;
type Flatten<T> = T extends Array<infer U> ? U : T;
export type AsyncState<T> = {
    isLoading: boolean;
    error?: undefined;
    data?: undefined;
} | {
    isLoading: true;
    error?: Error | undefined;
    data?: T;
} | {
    isLoading: false;
    error: Error;
    data?: undefined;
} | {
    isLoading: false;
    error?: undefined;
    data: T;
};
/**
 * Function to wrap an asynchronous update and gives some control about how the
 * hook's data should be updated while the update is going through.
 *
 * By default, the data will be revalidated (eg. the function will be called again)
 * after the update is done.
 *
 * **Optimistic Update**
 *
 * In an optimistic update, the UI behaves as though a change was successfully
 * completed before receiving confirmation from the server that it actually was -
 * it is being optimistic that it will eventually get the confirmation rather than an error.
 * This allows for a more responsive user experience.
 *
 * You can specify an `optimisticUpdate` function to mutate the data in order to reflect
 * the change introduced by the asynchronous update.
 *
 * When doing so, you can specify a `rollbackOnError` function to mutate back the
 * data if the asynchronous update fails. If not specified, the data will be automatically
 * rolled back to its previous value (before the optimistic update).
 */
export type MutatePromise<T, U = T, V = any> = (asyncUpdate?: Promise<V>, options?: {
    optimisticUpdate?: (data: T | U) => T;
    rollbackOnError?: boolean | ((data: T | U) => T);
    shouldRevalidateAfter?: boolean;
}) => Promise<V>;
type UsePromiseReturnType<T> = AsyncState<T> & {
    /**
     * Pagination information that can be passed to `List` or `Grid`.
     */
    pagination?: {
        pageSize: number;
        hasMore: boolean;
        onLoadMore: () => void;
    };
    /**
     * Function to manually call the function again
     */
    revalidate: () => Promise<T>;
    /**
     * Function to wrap an asynchronous update and gives some control about how the
     * hook's data should be updated while the update is going through.
     *
     * By default, the data will be revalidated (eg. the function will be called again)
     * after the update is done.
     *
     * **Optimistic Update**
     *
     * In an optimistic update, the UI behaves as though a change was successfully
     * completed before receiving confirmation from the server that it actually was -
     * it is being optimistic that it will eventually get the confirmation rather than an error.
     * This allows for a more responsive user experience.
     *
     * You can specify an `optimisticUpdate` function to mutate the data in order to reflect
     * the change introduced by the asynchronous update.
     *
     * When doing so, you can specify a `rollbackOnError` function to mutate back the
     * data if the asynchronous update fails. If not specified, the data will be automatically
     * rolled back to its previous value (before the optimistic update).
     */
    mutate: MutatePromise<T, undefined>;
};
type UseCachedPromiseReturnType<T, U> = AsyncState<T> & {
    /**
     * Pagination information that can be passed to `List` or `Grid`.
     */
    pagination?: {
        pageSize: number;
        hasMore: boolean;
        onLoadMore: () => void;
    };
    data: T | U;
    /**
     * Function to manually call the function again
     */
    revalidate: () => void;
    /**
     * Function to wrap an asynchronous update and gives some control about how the
     * hook's data should be updated while the update is going through.
     *
     * By default, the data will be revalidated (eg. the function will be called again)
     * after the update is done.
     *
     * **Optimistic Update**
     *
     * In an optimistic update, the UI behaves as though a change was successfully
     * completed before receiving confirmation from the server that it actually was -
     * it is being optimistic that it will eventually get the confirmation rather than an error.
     * This allows for a more responsive user experience.
     *
     * You can specify an `optimisticUpdate` function to mutate the data in order to reflect
     * the change introduced by the asynchronous update.
     *
     * When doing so, you can specify a `rollbackOnError` function to mutate back the
     * data if the asynchronous update fails. If not specified, the data will be automatically
     * rolled back to its previous value (before the optimistic update).
     */
    mutate: MutatePromise<T | U>;
};
/**
 * Shows a failure Toast for a given Error.
 *
 * @example
 * ```typescript
 * import { showHUD } from "@raycast/api";
 * import { runAppleScript, showFailureToast } from "@raycast/utils";
 *
 * export default async function () {
 *   try {
 *     const res = await runAppleScript(
 *       `
 *       on run argv
 *         return "hello, " & item 1 of argv & "."
 *       end run
 *       `,
 *       ["world"]
 *     );
 *     await showHUD(res);
 *   } catch (error) {
 *     showFailureToast(error, { title: "Could not run AppleScript" });
 *   }
 * }
 * ```
 */
export function showFailureToast(error: unknown, options?: Partial<Pick<Toast.Options, "title" | "primaryAction" | "message">>): Promise<Toast>;
export type PromiseOptions<T extends FunctionReturningPromise | FunctionReturningPaginatedPromise> = {
    /**
     * A reference to an `AbortController` to cancel a previous call when triggering a new one
     */
    abortable?: RefObject<AbortController | null | undefined>;
    /**
     * Whether to actually execute the function or not.
     * This is useful for cases where one of the function's arguments depends on something that
     * might not be available right away (for example, depends on some user inputs). Because React requires
     * every hooks to be defined on the render, this flag enables you to define the hook right away but
     * wait util you have all the arguments ready to execute the function.
     */
    execute?: boolean;
    /**
     * Options for the generic failure toast.
     * It allows you to customize the title, message, and primary action of the failure toast.
     */
    failureToastOptions?: Partial<Pick<Toast.Options, "title" | "primaryAction" | "message">>;
    /**
     * Called when an execution fails. By default it will log the error and show
     * a generic failure toast.
     */
    onError?: (error: Error) => void | Promise<void>;
    /**
     * Called when an execution succeeds.
     */
    onData?: (data: UnwrapReturn<T>, pagination?: PaginationOptions<UnwrapReturn<T>>) => void | Promise<void>;
    /**
     * Called when an execution will start
     */
    onWillExecute?: (parameters: Parameters<T>) => void;
};
/**
 * Wraps an asynchronous function or a function that returns a Promise in another function, and returns the {@link AsyncState} corresponding to the execution of the function.
 *
 * @remark This overload should be used when working with paginated data sources.
 *
 * @example
 * ```
 * import { setTimeout } from "node:timers/promises";
 * import { useState } from "react";
 * import { List } from "@raycast/api";
 * import { usePromise } from "@raycast/utils";
 *
 * export default function Command() {
 *   const [searchText, setSearchText] = useState("");
 *
 *   const { isLoading, data, pagination } = usePromise(
 *     (searchText: string) => async (options: { page: number }) => {
 *       await setTimeout(200);
 *       const newData = Array.from({ length: 25 }, (_v, index) => ({
 *         index,
 *         page: options.page,
 *         text: searchText,
 *       }));
 *       return { data: newData, hasMore: options.page < 10 };
 *     },
 *     [searchText]
 *   );
 *
 *   return (
 *     <List isLoading={isLoading} onSearchTextChange={setSearchText} pagination={pagination}>
 *       {data?.map((item) => (
 *         <List.Item
 *           key={`${item.page} ${item.index} ${item.text}`}
 *           title={`Page ${item.page} Item ${item.index}`}
 *           subtitle={item.text}
 *         />
 *       ))}
 *     </List>
 *   );
 * };
 * ```
 */
export function usePromise<T extends FunctionReturningPaginatedPromise<[]>>(fn: T): UsePromiseReturnType<UnwrapReturn<T>>;
export function usePromise<T extends FunctionReturningPaginatedPromise>(fn: T, args: Parameters<T>, options?: PromiseOptions<T>): UsePromiseReturnType<UnwrapReturn<T>>;
/**
 * Wraps an asynchronous function or a function that returns a Promise and returns the {@link AsyncState} corresponding to the execution of the function.
 *
 * @remark The function is assumed to be constant (eg. changing it won't trigger a revalidation).
 *
 * @example
 * ```
 * import { usePromise } from '@raycast/utils';
 *
 * export default function Command() {
 *   const abortable = useRef<AbortController>();
 *   const { isLoading, data, revalidate } = usePromise(async (url: string) => {
 *     const response = await fetch(url, { signal: abortable.current?.signal });
 *     const result = await response.text();
 *     return result
 *   },
 *   ['https://api.example'],
 *   {
 *     abortable
 *   });
 *
 *   return (
 *     <Detail
 *       isLoading={isLoading}
 *       markdown={data}
 *       actions={
 *         <ActionPanel>
 *           <Action title="Reload" onAction={() => revalidate()} />
 *         </ActionPanel>
 *       }
 *     />
 *   );
 * };
 * ```
 */
export function usePromise<T extends FunctionReturningPromise<[]>>(fn: T): UsePromiseReturnType<UnwrapReturn<T>>;
export function usePromise<T extends FunctionReturningPromise>(fn: T, args: Parameters<T>, options?: PromiseOptions<T>): UsePromiseReturnType<UnwrapReturn<T>>;
/**
 * Returns a stateful value, and a function to update it. The value will be kept between command runs.
 *
 * @remark The value needs to be JSON serializable.
 *
 * @param key - The unique identifier of the state. This can be used to share the state across components and/or commands.
 * @param initialState - The initial value of the state if there aren't any in the Cache yet.
 */
export function useCachedState<T>(key: string, initialState: T, config?: {
    cacheNamespace?: string;
}): [T, Dispatch<SetStateAction<T>>];
export function useCachedState<T = undefined>(key: string): [T | undefined, Dispatch<SetStateAction<T | undefined>>];
export type CachedPromiseOptions<T extends FunctionReturningPromise | FunctionReturningPaginatedPromise, U> = PromiseOptions<T> & {
    /**
     * The initial data if there aren't any in the Cache yet.
     */
    initialData?: U;
    /**
     * Tells the hook to keep the previous results instead of returning the initial value
     * if there aren't any in the cache for the new arguments.
     * This is particularly useful when used for data for a List to avoid flickering.
     */
    keepPreviousData?: boolean;
};
/**
 * Wraps an asynchronous function or a function that returns a Promise in another function, and returns the {@link AsyncState} corresponding to the execution of the function. The last value will be kept between command runs.
 *
 * @remark This overload should be used when working with paginated data sources.
 * @remark When paginating, only the first page will be cached.
 *
 * @example
 * ```
 * import { setTimeout } from "node:timers/promises";
 * import { useState } from "react";
 * import { List } from "@raycast/api";
 * import { useCachedPromise } from "@raycast/utils";
 *
 * export default function Command() {
 *   const [searchText, setSearchText] = useState("");
 *
 *   const { isLoading, data, pagination } = useCachedPromise(
 *     (searchText: string) => async (options: { page: number }) => {
 *       await setTimeout(200);
 *       const newData = Array.from({ length: 25 }, (_v, index) => ({
 *         index,
 *         page: options.page,
 *         text: searchText,
 *       }));
 *       return { data: newData, hasMore: options.page < 10 };
 *     },
 *     [searchText],
 *   );
 *
 *   return (
 *     <List isLoading={isLoading} onSearchTextChange={setSearchText} pagination={pagination}>
 *       {data?.map((item) => (
 *         <List.Item
 *           key={`${item.page} ${item.index} ${item.text}`}
 *           title={`Page ${item.page} Item ${item.index}`}
 *           subtitle={item.text}
 *         />
 *       ))}
 *     </List>
 *   );
 * }
 * ```
 */
export function useCachedPromise<T extends FunctionReturningPaginatedPromise<[]>>(fn: T): UseCachedPromiseReturnType<UnwrapReturn<T>, undefined>;
export function useCachedPromise<T extends FunctionReturningPaginatedPromise, U extends any[] = any[]>(fn: T, args: Parameters<T>, options?: CachedPromiseOptions<T, U>): UseCachedPromiseReturnType<UnwrapReturn<T>, U>;
/**
 * Wraps an asynchronous function or a function that returns a Promise and returns the {@link AsyncState} corresponding to the execution of the function. The last value will be kept between command runs.
 *
 * @remark The value needs to be JSON serializable.
 * @remark The function is assumed to be constant (eg. changing it won't trigger a revalidation).
 *
 * @example
 * ```
 * import { useCachedPromise } from '@raycast/utils';
 *
 * export default function Command() {
 *   const abortable = useRef<AbortController>();
 *   const { isLoading, data, revalidate } = useCachedPromise(async (url: string) => {
 *     const response = await fetch(url, { signal: abortable.current?.signal });
 *     const result = await response.text();
 *     return result
 *   },
 *   ['https://api.example'],
 *   {
 *     abortable
 *   });
 *
 *   return (
 *     <Detail
 *       isLoading={isLoading}
 *       markdown={data}
 *       actions={
 *         <ActionPanel>
 *           <Action title="Reload" onAction={() => revalidate()} />
 *         </ActionPanel>
 *       }
 *     />
 *   );
 * };
 * ```
 */
export function useCachedPromise<T extends FunctionReturningPromise<[]>>(fn: T): UseCachedPromiseReturnType<UnwrapReturn<T>, undefined>;
export function useCachedPromise<T extends FunctionReturningPromise, U = undefined>(fn: T, args: Parameters<T>, options?: CachedPromiseOptions<T, U>): UseCachedPromiseReturnType<UnwrapReturn<T>, U>;
type RequestInfo = string | URL | globalThis.Request;
type PaginatedRequestInfo = (pagination: {
    page: number;
    lastItem?: any;
    cursor?: any;
}) => RequestInfo;
/**
 * Fetches the paginatedURL and returns the {@link AsyncState} corresponding to the execution of the fetch. The last value will be kept between command runs.
 *
 * @remark This overload should be used when working with paginated data sources.
 * @remark When paginating, only the first page will be cached.
 *
 * @example
 * ```
 * import { Icon, Image, List } from "@raycast/api";
 * import { useFetch } from "@raycast/utils";
 * import { useState } from "react";
 *
 * type SearchResult = { companies: Company[]; page: number; totalPages: number };
 * type Company = { id: number; name: string; smallLogoUrl?: string };
 * export default function Command() {
 *   const [searchText, setSearchText] = useState("");
 *   const { isLoading, data, pagination } = useFetch(
 *     (options) =>
 *       "https://api.ycombinator.com/v0.1/companies?" +
 *       new URLSearchParams({ page: String(options.page + 1), q: searchText }).toString(),
 *     {
 *       mapResult(result: SearchResult) {
 *         return {
 *           data: result.companies,
 *           hasMore: result.page < result.totalPages,
 *         };
 *       },
 *       keepPreviousData: true,
 *       initialData: [],
 *     },
 *   );
 *
 *   return (
 *     <List isLoading={isLoading} pagination={pagination} onSearchTextChange={setSearchText}>
 *       {data.map((company) => (
 *         <List.Item
 *           key={company.id}
 *           icon={{ source: company.smallLogoUrl ?? Icon.MinusCircle, mask: Image.Mask.RoundedRectangle }}
 *           title={company.name}
 *         />
 *       ))}
 *     </List>
 *   );
 * }
 * ```
 */
export function useFetch<V = unknown, U = undefined, T extends unknown[] = unknown[]>(url: PaginatedRequestInfo, options: RequestInit & {
    mapResult: (result: V) => {
        data: T;
        hasMore?: boolean;
        cursor?: any;
    };
    parseResponse?: (response: Response) => Promise<V>;
} & Omit<CachedPromiseOptions<(url: RequestInfo, options?: RequestInit) => Promise<T>, U>, "abortable">): UseCachedPromiseReturnType<T, U>;
/**
 * Fetch the URL and returns the {@link AsyncState} corresponding to the execution of the fetch. The last value will be kept between command runs.
 *
 * @example
 * ```
 * import { useFetch } from '@raycast/utils';
 *
 * export default function Command() {
 *   const { isLoading, data, revalidate } = useFetch('https://api.example');
 *
 *   return (
 *     <Detail
 *       isLoading={isLoading}
 *       markdown={data}
 *       actions={
 *         <ActionPanel>
 *           <Action title="Reload" onAction={() => revalidate()} />
 *         </ActionPanel>
 *       }
 *     />
 *   );
 * };
 * ```
 */
export function useFetch<V = unknown, U = undefined, T = V>(url: RequestInfo, options?: RequestInit & {
    mapResult?: (result: V) => {
        data: T;
        hasMore?: boolean;
        cursor?: any;
    };
    parseResponse?: (response: Response) => Promise<V>;
} & Omit<CachedPromiseOptions<(url: RequestInfo, options?: RequestInit) => Promise<T>, U>, "abortable">): UseCachedPromiseReturnType<T, U> & {
    pagination: undefined;
};
type ParseExecOutputHandler<T, DecodedOutput extends string | Buffer = string | Buffer, Options = unknown> = (args: {
    /** The output of the process on stdout. */
    stdout: DecodedOutput;
    /** The output of the process on stderr. */
    stderr: DecodedOutput;
    error?: Error;
    /** The numeric exit code of the process that was run. */
    exitCode: number | null;
    /**
     * The name of the signal that was used to terminate the process. For example, SIGFPE.
     *
     * If a signal terminated the process, this property is defined. Otherwise it is null.
     */
    signal: NodeJS.Signals | null;
    /** Whether the process timed out. */
    timedOut: boolean;
    /** The command that was run, for logging purposes. */
    command: string;
    options?: Options;
}) => T;
type ExecOptions = {
    /**
     * If `true`, runs the command inside of a shell. Uses `/bin/sh`. A different shell can be specified as a string. The shell should understand the `-c` switch.
     *
     * We recommend against using this option since it is:
     * - not cross-platform, encouraging shell-specific syntax.
     * - slower, because of the additional shell interpretation.
     * - unsafe, potentially allowing command injection.
     *
     * @default false
     */
    shell?: boolean | string;
    /**
     * Strip the final newline character from the output.
     * @default true
     */
    stripFinalNewline?: boolean;
    /**
     * Current working directory of the child process.
     * @default process.cwd()
     */
    cwd?: string;
    /**
     * Environment key-value pairs. Extends automatically from `process.env`.
     * @default process.env
     */
    env?: NodeJS.ProcessEnv;
    /**
     * Specify the character encoding used to decode the stdout and stderr output. If set to `"buffer"`, then stdout and stderr will be a Buffer instead of a string.
     *
     * @default "utf8"
     */
    encoding?: BufferEncoding | "buffer";
    /**
     * Write some input to the `stdin` of your binary.
     */
    input?: string | Buffer;
    /** If timeout is greater than `0`, the parent will send the signal `SIGTERM` if the child runs longer than timeout milliseconds.
     *
     * @default 10000
     */
    timeout?: number;
};
type ExecCachedPromiseOptions<T, U> = Omit<CachedPromiseOptions<(_command: string, _args: string[], _options?: ExecOptions, input?: string | Buffer) => Promise<T>, U>, "abortable">;
/**
 * Executes a command and returns the {@link AsyncState} corresponding to the execution of the command. The last value will be kept between command runs.
 *
 * @remark When specifying the arguments via the `command` string, if the file or an argument of the command contains spaces, they must be escaped with backslashes. This matters especially if `command` is not a constant but a variable, for example with `__dirname` or `process.cwd()`. Except for spaces, no escaping/quoting is needed.
 *
 * The `shell` option must be used if the command uses shell-specific features (for example, `&&` or `||`), as opposed to being a simple file followed by its arguments.
 *
 * @example
 * ```
 * import { useExec } from '@raycast/utils';
 *
 * export default function Command() {
 *   const { isLoading, data, revalidate } = useExec("brew", ["info", "--json=v2", "--installed"]);
 *   const results = useMemo<{}[]>(() => JSON.parse(data || "[]"), [data]);
 *
 *   return (
 *     <List isLoading={isLoading}>
 *      {(data || []).map((item) => (
 *        <List.Item key={item.id} title={item.name} />
 *      ))}
 *    </List>
 *   );
 * };
 * ```
 */
export function useExec<T = Buffer, U = undefined>(command: string, options: {
    parseOutput?: ParseExecOutputHandler<T, Buffer, ExecOptions>;
} & ExecOptions & {
    encoding: "buffer";
} & ExecCachedPromiseOptions<T, U>): UseCachedPromiseReturnType<T, U>;
export function useExec<T = string, U = undefined>(command: string, options?: {
    parseOutput?: ParseExecOutputHandler<T, string, ExecOptions>;
} & ExecOptions & {
    encoding?: BufferEncoding;
} & ExecCachedPromiseOptions<T, U>): UseCachedPromiseReturnType<T, U>;
export function useExec<T = Buffer, U = undefined>(file: string, 
/**
 * The arguments to pass to the file. No escaping/quoting is needed.
 *
 * If defined, the commands needs to be a file to execute. If undefined, the arguments will be parsed from the command.
 */
args: string[], options: {
    parseOutput?: ParseExecOutputHandler<T, Buffer, ExecOptions>;
} & ExecOptions & {
    encoding: "buffer";
} & ExecCachedPromiseOptions<T, U>): UseCachedPromiseReturnType<T, U>;
export function useExec<T = string, U = undefined>(file: string, 
/**
 * The arguments to pass to the file. No escaping/quoting is needed.
 *
 * If defined, the commands needs to be a file to execute. If undefined, the arguments will be parsed from the command.
 */
args: string[], options?: {
    parseOutput?: ParseExecOutputHandler<T, string, ExecOptions>;
} & ExecOptions & {
    encoding?: BufferEncoding;
} & ExecCachedPromiseOptions<T, U>): UseCachedPromiseReturnType<T, U>;
type _RequestInfo1 = string | URL | globalThis.Request;
type Options<T> = {
    /**
     * The hook expects to iterate through an array of data, so by default, it assumes the JSON it receives itself represents an array. However, sometimes the array of data is wrapped in an object,
     * i.e. `{ "success": true, "data": […] }`, or even `{ "success": true, "results": { "data": […] } }`. In those cases, you can use `dataPath` to specify where the data array can be found.
     *
     * @remark If your JSON object has multiple arrays that you want to stream data from, you can pass a regular expression to stream through all of them.
     *
     * @example For `{ "success": true, "data": […] }`, dataPath would be `data`
     * @example For `{ "success": true, "results": { "data": […] } }`, dataPath would be `results.data`
     * @example For `{ "success": true, "results": { "first_list": […], "second_list": […], "third_list": […] } }`, dataPath would be `/^results\.(first_list|second_list|third_list)$
  /`.
     */
    dataPath?: string | RegExp;
    /**
     * A function to decide whether a particular item should be kept or not.
     * Defaults to `undefined`, keeping any encountered item.
     *
     * @remark The hook will revalidate every time the filter function changes, so you need to use [useCallback](https://react.dev/reference/react/useCallback) to make sure it only changes when it needs to.
     */
    filter?: (item: Flatten<T>) => boolean;
    /**
     * A function to apply to each item as it is encountered. Useful for a couple of things:
     * 1. ensuring that all items have the expected properties, and, as on optimization, for getting rid of the properties that you don't care about.
     * 2. when top-level objects actually represent nested data, which should be flattened. In this case, `transform` can return an array of items, and the hook will stream through each one of those items,
     * passing them to `filter` etc.
     *
     * Defaults to a passthrough function if not provided.
     *
     * @remark The hook will revalidate every time the transform function changes, so it is important to use [useCallback](https://react.dev/reference/react/useCallback) to ensure it only changes when necessary to prevent unnecessary re-renders or computations.
     *
     * @example
     * ```
     * // For data: `{ "data": [ { "type": "folder", "name": "item 1", "children": [ { "type": "item", "name": "item 2" }, { "type": "item", "name": "item 3" } ] }, { "type": "folder", "name": "item 4", children: [] } ] }`
     *
     * type Item = {
     *  type: "item";
     *  name: string;
     * };
     *
     * type Folder = {
     *   type: "folder";
     *   name: string;
     *   children: (Item | Folder)[];
     * };
     *
     * function flatten(item: Item | Folder): { name: string }[] {
     *   const flattened: { name: string }[] = [];
     *   if (item.type === "folder") {
     *     flattened.push(...item.children.map(flatten).flat());
     *   }
     *   if (item.type === "item") {
     *     flattened.push({ name: item.name });
     *   }
     *   return flattened;
     * }
     *
     * const transform = useCallback(flatten, []);
     * const filter = useCallback((item: { name: string }) => {
     *   …
     * })
     * ```
     */
    transform?: (item: any) => T;
    /**
     * The amount of items to return for each page.
     * Defaults to `20`.
     */
    pageSize?: number;
};
/**
 * Takes a `http://`, `https://` or `file:///` URL pointing to a JSON resource, caches it to the command's support
 * folder, and streams through its content. Useful when dealing with large JSON arrays which would be too big to fit
 * in the command's memory.
 *
 * @remark The JSON resource needs to consist of an array of objects
 *
 * @example
 * ```
 * import { List } from "@raycast/api";
 * import { useStreamJSON } from "@raycast/utils";
 *
 * type Formula = { name: string; desc?: string };
 *
 * export default function Main(): React.JSX.Element {
 *   const { data, isLoading, pagination } = useStreamJSON<Formula>("https://formulae.brew.sh/api/formula.json");
 *
 *   return (
 *     <List isLoading={isLoading} pagination={pagination}>
 *       <List.Section title="Formulae">
 *         {data?.map((d) => <List.Item key={d.name} title={d.name} subtitle={d.desc} />)}
 *       </List.Section>
 *     </List>
 *   );
 * }
 * ```
 *
 * @example
 * ```
 * import { List } from "@raycast/api";
 * import { useStreamJSON } from "@raycast/utils";
 * import { homedir } from "os";
 * import { join } from "path";
 *
 * type Formula = { name: string; desc?: string };
 *
 * export default function Main(): React.JSX.Element {
 *   const { data, isLoading, pagination } = useStreamJSON<Formula>(`file:///${join(homedir(), "Downloads", "formulae.json")}`);
 *
 *   return (
 *     <List isLoading={isLoading} pagination={pagination}>
 *       <List.Section title="Formulae">
 *         {data?.map((d) => <List.Item key={d.name} title={d.name} subtitle={d.desc} />)}
 *       </List.Section>
 *     </List>
 *   );
 * }
 * ```
 */
export function useStreamJSON<T, U = unknown>(url: _RequestInfo1): UseCachedPromiseReturnType<T, U>;
/**
 * Takes a `http://`, `https://` or `file:///` URL pointing to a JSON resource, caches it to the command's support
 * folder, and streams through its content. Useful when dealing with large JSON arrays which would be too big to fit
 * in the command's memory.
 *
 * @remark The JSON resource needs to consist of an array of objects
 *
 * @example
 * ```
 * import { List, environment } from "@raycast/api";
 * import { useStreamJSON } from "@raycast/utils";
 * import { join } from 'path';
 * import { useCallback, useState } from "react";
 *
 * type Formula = { name: string; desc?: string };
 *
 * export default function Main(): React.JSX.Element {
 *   const [searchText, setSearchText] = useState("");
 *
 *   const formulaFilter = useCallback(
 *     (item: Formula) => {
 *       if (!searchText) return true;
 *       return item.name.toLocaleLowerCase().includes(searchText);
 *     },
 *     [searchText],
 *   );
 *
 *   const formulaTransform = useCallback((item: any): Formula => {
 *     return { name: item.name, desc: item.desc };
 *   }, []);
 *
 *   const { data, isLoading, pagination } = useStreamJSON("https://formulae.brew.sh/api/formula.json", {
 *     initialData: [] as Formula[],
 *     pageSize: 20,
 *     filter: formulaFilter,
 *     transform: formulaTransform,
 *   });
 *
 *   return (
 *     <List isLoading={isLoading} pagination={pagination} onSearchTextChange={setSearchText}>
 *       <List.Section title="Formulae">
 *         {data.map((d) => (
 *           <List.Item key={d.name} title={d.name} subtitle={d.desc} />
 *         ))}
 *       </List.Section>
 *     </List>
 *   );
 * }
 * ``` support folder, and streams through its content.
 *
 * @example
 * ```
 * import { List, environment } from "@raycast/api";
 * import { useStreamJSON } from "@raycast/utils";
 * import { join } from "path";
 * import { homedir } from "os";
 * import { useCallback, useState } from "react";
 *
 * type Formula = { name: string; desc?: string };
 *
 * export default function Main(): React.JSX.Element {
 *   const [searchText, setSearchText] = useState("");
 *
 *   const formulaFilter = useCallback(
 *     (item: Formula) => {
 *       if (!searchText) return true;
 *       return item.name.toLocaleLowerCase().includes(searchText);
 *     },
 *     [searchText],
 *   );
 *
 *   const formulaTransform = useCallback((item: any): Formula => {
 *     return { name: item.name, desc: item.desc };
 *   }, []);
 *
 *   const { data, isLoading, pagination } = useStreamJSON(`file:///${join(homedir(), "Downloads", "formulae.json")}`, {
 *     initialData: [] as Formula[],
 *     pageSize: 20,
 *     filter: formulaFilter,
 *     transform: formulaTransform,
 *   });
 *
 *   return (
 *     <List isLoading={isLoading} pagination={pagination} onSearchTextChange={setSearchText}>
 *       <List.Section title="Formulae">
 *         {data.map((d) => (
 *           <List.Item key={d.name} title={d.name} subtitle={d.desc} />
 *         ))}
 *       </List.Section>
 *     </List>
 *   );
 * }
 * ```
 */
export function useStreamJSON<T, U extends any[] = any[]>(url: _RequestInfo1, options: Options<T> & RequestInit & Omit<CachedPromiseOptions<FunctionReturningPaginatedPromise, U>, "abortable">): UseCachedPromiseReturnType<T extends unknown[] ? T : T[], U>;
/**
 * Executes a query on a local SQL database and returns the {@link AsyncState} corresponding to the query of the command. The last value will be kept between command runs.
 *
 * @example
 * ```
 * import { useSQL } from "@raycast/utils";
 * import { resolve } from "path";
 * import { homedir } from "os";
 *
 * const NOTES_DB = resolve(homedir(), "Library/Group Containers/group.com.apple.notes/NoteStore.sqlite");
 * const notesQuery = `SELECT id, title FROM ...`;
 * type NoteItem = {
 *   id: string;
 *   title: string;
 * };
 *
 * export default function Command() {
 *   const { isLoading, data, permissionView } = useSQL<NoteItem>(NOTES_DB, notesQuery);
 *
 *   if (permissionView) {
 *     return permissionView;
 *   }
 *
 *   return (
 *     <List isLoading={isLoading}>
 *       {(data || []).map((item) => (
 *         <List.Item key={item.id} title={item.title} />
 *       ))}
 *     </List>
 *  );
 * };
 * ```
 */
export function useSQL<T = unknown>(databasePath: string, query: string, options?: {
    /** A string explaining why the extension needs full disk access. For example, the Apple Notes extension uses `"This is required to search your Apple Notes."`. While it is optional, we recommend setting it to help users understand. */
    permissionPriming?: string;
} & Omit<PromiseOptions<(database: string, query: string) => Promise<T[]>>, "abortable">): {
    permissionView: JSX.Element | null;
    isLoading: boolean;
    error?: undefined;
    data?: undefined;
    pagination?: {
        pageSize: number;
        hasMore: boolean;
        onLoadMore: () => void;
    };
    revalidate: () => Promise<T[]>;
    mutate: MutatePromise<T[], undefined, any>;
} | {
    permissionView: JSX.Element | null;
    isLoading: false;
    error: Error;
    data?: undefined;
    pagination?: {
        pageSize: number;
        hasMore: boolean;
        onLoadMore: () => void;
    };
    revalidate: () => Promise<T[]>;
    mutate: MutatePromise<T[], undefined, any>;
} | {
    permissionView: JSX.Element | null;
    isLoading: true;
    error?: Error | undefined;
    data?: T[] | undefined;
    pagination?: {
        pageSize: number;
        hasMore: boolean;
        onLoadMore: () => void;
    };
    revalidate: () => Promise<T[]>;
    mutate: MutatePromise<T[], undefined, any>;
} | {
    permissionView: JSX.Element | null;
    isLoading: false;
    error?: undefined;
    data: T[];
    pagination?: {
        pageSize: number;
        hasMore: boolean;
        onLoadMore: () => void;
    };
    revalidate: () => Promise<T[]>;
    mutate: MutatePromise<T[], undefined, any>;
};
/**
 * Shorthands for common validation cases
 */
export enum FormValidation {
    /** Show an error when the value of the item is empty */
    Required = "required"
}
type ValidationError = string | undefined | null;
type Validator<ValueType> = ((value: ValueType | undefined) => ValidationError) | FormValidation;
type Validation<T extends Form.Values> = {
    [id in keyof T]?: Validator<T[id]>;
};
interface FormProps<T extends Form.Values> {
    /** Function to pass to the `onSubmit` prop of the `<Action.SubmitForm>` element. It wraps the initial `onSubmit` argument with some goodies related to the validation. */
    handleSubmit: (values: T) => void | boolean | Promise<void | boolean>;
    /** The props that must be passed to the `<Form.Item>` elements to handle the validations. */
    itemProps: {
        [id in keyof Required<T>]: Partial<Form.ItemProps<T[id]>> & {
            id: string;
        };
    };
    /** Function that can be used to programmatically set the validation of a specific field. */
    setValidationError: (id: keyof T, error: ValidationError) => void;
    /** Function that can be used to programmatically set the value of a specific field. */
    setValue: <K extends keyof T>(id: K, value: SetStateAction<T[K]>) => void;
    /** The current values of the form. */
    values: T;
    /** Function that can be used to programmatically focus a specific field. */
    focus: (id: keyof T) => void;
    /** Function that can be used to reset the values of the Form. */
    reset: (initialValues?: Partial<T>) => void;
}
/**
 * Hook that provides a high-level interface to work with Forms, and more particularly, with Form validations. It incorporates all the good practices to provide a great User Experience for your Forms.
 *
 * @returns an object which contains the necessary methods and props to provide a good User Experience in your Form.
 *
 * @example
 * ```
 * import { Action, ActionPanel, Form, showToast, Toast } from "@raycast/api";
 * import { useForm, FormValidation } from "@raycast/utils";
 *
 * interface SignUpFormValues {
 *   nickname: string;
 *   password: string;
 * }
 *
 * export default function Command() {
 *   const { handleSubmit, itemProps } = useForm<SignUpFormValues>({
 *     onSubmit(values) {
 *       showToast(Toast.Style.Success, "Yay!", `${values.nickname} account created`);
 *     },
 *     validation: {
 *       nickname: FormValidation.Required,
 *       password: (value) => {
 *         if (value && value.length < 8) {
 *           return "Password must be at least 8 symbols";
 *         } else if (!value) {
 *           return "The item is required";
 *         }
 *       },
 *     },
 *   });
 *
 *   return (
 *     <Form
 *       actions={
 *         <ActionPanel>
 *           <Action.SubmitForm title="Submit" onSubmit={handleSubmit} />
 *         </ActionPanel>
 *       }
 *     >
 *       <Form.TextField title="Nickname" placeholder="Enter your nickname" {...itemProps.nickname} />
 *       <Form.PasswordField
 *         title="Password"
 *         placeholder="Enter password at least 8 characters long"
 *         {...itemProps.password}
 *       />
 *     </Form>
 *   );
 * }
 * ```
 */
export function useForm<T extends Form.Values>(props: {
    /** Callback that will be called when the form is submitted and all validations pass. */
    onSubmit: (values: T) => void | boolean | Promise<void | boolean>;
    /** The initial values to set when the Form is first rendered. */
    initialValues?: Partial<T>;
    /** The validation rules for the Form. A validation for a Form item is a function that takes the current value of the item as an argument and must return a string when the validation is failing.
     *
     * There are also some shorthands for common cases, see {@link FormValidation}.
     * */
    validation?: Validation<T>;
}): FormProps<T>;
/**
 * Stream a prompt completion.
 *
 * @example
 * ```typescript
 * import { Detail, LaunchProps } from "@raycast/api";
 * import { use AI } from "@raycast/utils";
 *
 * export default function Command(props: LaunchProps<{ arguments: { prompt: string } }>) {
 *   const { isLoading, data } = useAI(props.arguments.prompt);
 *
 *   return <Detail isLoading={isLoading} markdown={data} />;
 * }
 * ```
 */
export function useAI(prompt: string, options?: {
    /**
     * Concrete tasks, such as fixing grammar, require less creativity while open-ended questions, such as generating ideas, require more.
     * If a number is passed, it needs to be in the range 0-2. For larger values, 2 will be used. For lower values, 0 will be used.
     */
    creativity?: AI.Creativity;
    /**
     * The AI model to use to answer to the prompt.
     */
    model?: AI.Model;
    /**
     * Whether to stream the answer or only update the data when the entire answer has been received.
     */
    stream?: boolean;
} & Omit<PromiseOptions<FunctionReturningPromise>, "abortable">): {
    isLoading: boolean;
    data: string;
    error: Error | undefined;
    revalidate: () => Promise<void>;
};
/**
 * Sort an array by its frecency and provide methods to update the frecency of its items.
 * Frecency is a measure that combines frequency and recency. The more often an item is visited/used, and the more recently an item is visited/used, the higher it will rank.
 *
 * @example
 * ```
 * import { List, ActionPanel, Action, Icon } from "@raycast/api";
 * import { useFetch, useFrecencySorting } from "@raycast/utils";
 *
 * export default function Command() {
 *   const { isLoading, data } = useFetch("https://api.example");
 *   const { data: sortedData, visitItem, resetRanking } = useFrecencySorting(data);
 *
 *   return (
 *     <List isLoading={isLoading}>
 *       {sortedData.map((item) => (
 *         <List.Item
 *           key={item.id}
 *           title={item.title}
 *           actions={
 *             <ActionPanel>
 *               <Action.OpenInBrowser url={item.url} onOpen={() => visitItem(item)} />
 *               <Action.CopyToClipboard title="Copy Link" content={item.url} onCopy={() => visitItem(item)} />
 *               <Action title="Reset Ranking" icon={Icon.ArrowCounterClockwise} onAction={() => resetRanking(item)} />
 *             </ActionPanel>
 *           }
 *         />
 *       ))}
 *     </List>
 *   );
 * };
 * ```
 */
export function useFrecencySorting<T extends {
    id: string;
}>(data?: T[], options?: {
    namespace?: string;
    key?: (item: T) => string;
    sortUnvisited?: (a: T, b: T) => number;
}): {
    data: T[];
    visitItem: (item: T) => Promise<void>;
    resetRanking: (item: T) => Promise<void>;
};
export function useFrecencySorting<T>(data: T[] | undefined, options: {
    namespace?: string;
    key: (item: T) => string;
    sortUnvisited?: (a: T, b: T) => number;
}): {
    data: T[];
    visitItem: (item: T) => Promise<void>;
    resetRanking: (item: T) => Promise<void>;
};
/**
 * A hook to manage a value in the local storage.
 *
 * @remark The value is stored as a JSON string in the local storage.
 *
 * @param key - The key to use for the value in the local storage.
 * @param initialValue - The initial value to use if the key doesn't exist in the local storage.
 * @returns An object with the following properties:
 * - `value`: The value from the local storage or the initial value if the key doesn't exist.
 * - `setValue`: A function to update the value in the local storage.
 * - `removeValue`: A function to remove the value from the local storage.
 * - `isLoading`: A boolean indicating if the value is loading.
 *
 * @example
 * ```
 * const { value, setValue } = useLocalStorage<string>("my-key");
 * const { value, setValue } = useLocalStorage<string>("my-key", "default value");
 * ```
 */
export function useLocalStorage<T>(key: string, initialValue?: T): {
    value: Awaited<T> | undefined;
    setValue: (value: T) => Promise<void>;
    removeValue: () => Promise<void>;
    isLoading: boolean;
};
/**
 * Icon to represent an avatar when you don't have one. The generated avatar
 * will be generated from the initials of the name and have a colorful but consistent background.
 *
 * @returns an Image that can be used where Raycast expects them.
 *
 * @example
 * ```
 * <List.Item icon={getAvatarIcon('Mathieu Dutour')} title="Project" />
 * ```
 */
export function getAvatarIcon(name: string, options?: {
    /**
     * Custom background color
     */
    background?: string;
    /**
     * Whether to use a gradient for the background or not.
     * @default true
     */
    gradient?: boolean;
}): Image.Asset;
/**
 * Icon showing the favicon of a website.
 *
 * A favicon (favorite icon) is a tiny icon included along with a website, which is displayed in places like the browser's address bar, page tabs, and bookmarks menu.
 *
 * @param url The URL of the website to represent.
 *
 * @returns an Image that can be used where Raycast expects them.
 *
 * @example
 * ```
 * <List.Item icon={getFavicon("https://raycast.com")} title="Raycast Website" />
 * ```
 */
export function getFavicon(url: string | URL, options?: {
    /**
     * Size of the Favicon
     * @default 64
     */
    size?: number;
    /**
     * Fallback icon in case the Favicon is not found.
     * @default Icon.Link
     */
    fallback?: Image.Fallback;
    /**
     * A {@link Image.Mask} to apply to the Favicon.
     */
    mask?: Image.Mask;
}): Image.ImageLike;
/**
 * Icon to represent the progress of _something_.
 *
 * @param progress Number between 0 and 1.
 * @param color Hex color (default `"#FF6363"`) or Color.
 *
 * @returns an Image that can be used where Raycast expects them.
 *
 * @example
 * ```
 * <List.Item icon={getProgressIcon(0.1)} title="Project" />
 * ```
 */
export function getProgressIcon(progress: number, color?: Color | string, options?: {
    background?: Color | string;
    backgroundOpacity?: number;
}): Image.Asset;
type OAuthType = "oauth" | "personal";
export type OnAuthorizeParams = {
    type: OAuthType;
    token: string;
    idToken?: string;
};
export interface OAuthServiceOptions {
    client: OAuth.PKCEClient;
    clientId: string;
    scope: string | string[];
    authorizeUrl: string;
    tokenUrl: string;
    refreshTokenUrl?: string;
    personalAccessToken?: string;
    bodyEncoding?: "json" | "url-encoded";
    extraParameters?: Record<string, string>;
    onAuthorize?: (params: OnAuthorizeParams) => void;
    tokenResponseParser?: (response: unknown) => OAuth.TokenResponse;
    tokenRefreshResponseParser?: (response: unknown) => OAuth.TokenResponse;
}
type BaseProviderOptions = {
    scope: string;
    personalAccessToken?: string;
    authorizeUrl?: string;
    tokenUrl?: string;
    refreshTokenUrl?: string;
    onAuthorize?: (params: OnAuthorizeParams) => void;
    bodyEncoding?: "json" | "url-encoded";
    tokenResponseParser?: (response: unknown) => OAuth.TokenResponse;
    tokenRefreshResponseParser?: (response: unknown) => OAuth.TokenResponse;
};
export type ProviderWithDefaultClientOptions = BaseProviderOptions & {
    clientId?: string;
};
export type ProviderOptions = BaseProviderOptions & {
    clientId: string;
};
/**
 * Class allowing to create an OAuth service using the the PKCE (Proof Key for Code Exchange) flow.
 *
 * This service is capable of starting the authorization process, fetching and refreshing tokens,
 * as well as managing the authentication state.
 *
 * @example
 * ```typescript
 * const oauthClient = new OAuth.PKCEClient({ ... });
 * const oauthService = new OAuthService({
 *   client: oauthClient,
 *   clientId: 'your-client-id',
 *   scope: 'required scopes',
 *   authorizeUrl: 'https://provider.com/oauth/authorize',
 *   tokenUrl: 'https://provider.com/oauth/token',
 *   refreshTokenUrl: 'https://provider.com/oauth/token',
 *   extraParameters: { 'additional_param': 'value' }
 * });
 * ```
 */
export class OAuthService implements OAuthServiceOptions {
    clientId: string;
    scope: string;
    client: OAuth.PKCEClient;
    extraParameters?: Record<string, string>;
    authorizeUrl: string;
    tokenUrl: string;
    refreshTokenUrl?: string;
    bodyEncoding?: "json" | "url-encoded";
    personalAccessToken?: string;
    onAuthorize?: (params: OnAuthorizeParams) => void;
    tokenResponseParser: (response: unknown) => OAuth.TokenResponse;
    tokenRefreshResponseParser: (response: unknown) => OAuth.TokenResponse;
    constructor(options: OAuthServiceOptions);
    /**
     * Asana OAuth service provided out of the box.
     *
     * @example
     * ```typescript
     * const asana = OAuthService.asana({ scope: 'default' })
     * ```
     */
    static asana(options: ProviderWithDefaultClientOptions): OAuthService;
    /**
     * GitHub OAuth service provided out of the box.
     *
     * @example
     * ```typescript
     * const github = OAuthService.github({ scope: 'repo user' })
     * ```
     */
    static github(options: ProviderWithDefaultClientOptions): OAuthService;
    /**
     * Google OAuth service provided out of the box.
     *
     * @example
     * ```typescript
     * const google = OAuthService.google({
     *   clientId: 'custom-client-id',
     *   authorizeUrl: 'https://accounts.google.com/o/oauth2/v2/auth',
     *   tokenUrl: 'https://oauth2.googleapis.com/token',
     *   scope: 'https://www.googleapis.com/auth/drive.readonly',
     * });
     * ```
     */
    static google(options: ProviderOptions): OAuthService;
    /**
     * Jira OAuth service provided out of the box.
     *
     * @example
     * ```typescript
     * const jira = OAuthService.jira({
     *   clientId: 'custom-client-id',
     *   authorizeUrl: 'https://auth.atlassian.com/authorize',
     *   tokenUrl: 'https://api.atlassian.com/oauth/token',
     *   scope: 'read:jira-user read:jira-work offline_access'
     * });
     * ```
     */
    static jira(options: ProviderOptions): OAuthService;
    /**
     * Linear OAuth service provided out of the box.
     *
     * @example
     * ```typescript
     * const linear = OAuthService.linear({ scope: 'read write' })
     * ```
     */
    static linear(options: ProviderWithDefaultClientOptions): OAuthService;
    /**
     * Slack OAuth service provided out of the box.
     *
     * @example
     * ```typescript
     * const slack = OAuthService.slack({ scope: 'emoji:read' })
     * ```
     */
    static slack(options: ProviderWithDefaultClientOptions): OAuthService;
    /**
     * Zoom OAuth service provided out of the box.
     *
     * @example
     * ```typescript
     * const zoom = OAuthService.zoom({
     *   clientId: 'custom-client-id',
     *   authorizeUrl: 'https://zoom.us/oauth/authorize',
     *   tokenUrl: 'https://zoom.us/oauth/token',
     *   scope: 'meeting:write',
     *   personalAccessToken: 'personal-access-token',
     * });
     * ```
     */
    static zoom(options: ProviderOptions): OAuthService;
    /**
     * Initiates the OAuth authorization process or refreshes existing tokens if necessary.
     * If the current token set has a refresh token and it is expired, then the function will refresh the tokens.
     * If no tokens exist, it will initiate the OAuth authorization process and fetch the tokens.
     *
     * @returns {Promise<string>} A promise that resolves with the access token obtained from the authorization flow, or null if the token could not be obtained.
     */
    authorize(): Promise<string>;
}
type WithAccessTokenParameters = {
    /**
     * An optional instance of a PKCE Client that you can create using Raycast API.
     * This client is used to return the `idToken` as part of the `onAuthorize` callback.
     */
    client?: OAuth.PKCEClient;
    /**
     * A function that initiates the OAuth token retrieval process
     * @returns a promise that resolves to an access token.
     */
    authorize: () => Promise<string>;
    /**
     * An optional string that represents an already obtained personal access token
     */
    personalAccessToken?: string;
    /**
     * An optional callback function that is called once the user has been properly logged in through OAuth.
     * @param {object} params - Parameters of the callback
     * @param {string} options.token - The retrieved access token
     * @param {string} options.type - The access token's type (either `oauth` or `personal`)
     * @param {string} options.idToken - The optional id token. The `idToken` is returned if `options.client` is provided and if it's returned in the initial token set.
     */
    onAuthorize?: (params: OnAuthorizeParams) => void;
};
/**
 * The component (for a view/menu-bar commands) or function (for a no-view command) that is passed to withAccessToken.
 */
export type WithAccessTokenComponentOrFn<T = any, U = any> = ((params: T) => Promise<U> | U) | React.ComponentType<T>;
/**
 * Higher-order component to wrap a given component or function and set an access token in a shared global variable.
 *
 * The function intercepts the component rendering process to either fetch an OAuth token asynchronously
 * or use a provided personal access token. A global variable will be then set with the received token
 * that you can get with the `getAccessToken` function.
 *
 * @example
 * ```typescript
 * import { Detail } from "@raycast/api";
 * import { OAuthService, getAccessToken, withAccessToken } from "@raycast/utils";
 *
 * const github = OAuthService.github({ scope: "notifications repo read:org read:user read:project" });
 *
 * function AuthorizedComponent() {
 *  const { token } = getAccessToken();
 *  ...
 * }
 *
 * export default withAccessToken(github)(AuthorizedComponent);
 * ```
 *
 * @returns {React.ComponentType<T>} The wrapped component.
 */
export function withAccessToken<T = any, U = any>(options: WithAccessTokenParameters): <V extends WithAccessTokenComponentOrFn<T, U>>(fnOrComponent: V) => V extends React.ComponentType<T> ? React.FunctionComponent<T> : (props: T) => Promise<U>;
/**
 * Returns the access token and its type. Note that this function must be called in a component wrapped with `withAccessToken`.
 *
 * Will throw an Error if called outside of a function or component wrapped with `withAccessToken`
 *
 * @returns {{ token: string, type: "oauth" | "personal" }} An object containing the `token`
 * and its `type`, where type can be either 'oauth' for OAuth tokens or 'personal' for a
 * personal access token.
 */
export function getAccessToken(): {
    token: string;
    /** `oauth` for OAuth tokens or `personal` for personal access token */
    type: "oauth" | "personal";
};
export enum DeeplinkType {
    /** A script command */
    ScriptCommand = "script-command",
    /** An extension command */
    Extension = "extension"
}
/**
 * Options for creating a deeplink to a script command.
 */
type CreateScriptCommandDeeplinkOptions = {
    /**
     * The type of deeplink, which should be "script-command".
     */
    type: DeeplinkType.ScriptCommand;
    /**
     * The name of the command.
     */
    command: string;
    /**
     * If the command accepts arguments, they can be passed using this query parameter.
     */
    arguments?: string[];
};
/**
 * Base options for creating a deeplink to an extension.
 */
type CreateExtensionDeeplinkBaseOptions = {
    /**
     * The type of deeplink, which should be "extension".
     */
    type?: DeeplinkType.Extension;
    /**
     * The command associated with the extension.
     */
    command: string;
    /**
     * Either "userInitiated", which runs the command in the foreground, or "background", which skips bringing Raycast to the front.
     */
    launchType?: LaunchType;
    /**
     * If the command accepts arguments, they can be passed using this query parameter.
     */
    arguments?: LaunchProps["arguments"];
    /**
     * If the command make use of LaunchContext, it can be passed using this query parameter.
     */
    context?: LaunchProps["launchContext"];
    /**
     * Some text to prefill the search bar or first text input of the command
     */
    fallbackText?: string;
};
/**
 * Options for creating a deeplink to an extension from another extension.
 * Requires both the ownerOrAuthorName and extensionName.
 */
type CreateInterExtensionDeeplinkOptions = CreateExtensionDeeplinkBaseOptions & {
    /**
     * The name of the owner or author of the extension.
     */
    ownerOrAuthorName: string;
    /**
     * The name of the extension.
     */
    extensionName: string;
};
/**
 * Options for creating a deeplink to an extension.
 */
type CreateExtensionDeeplinkOptions = CreateInterExtensionDeeplinkOptions | CreateExtensionDeeplinkBaseOptions;
/**
 * Options for creating a deeplink.
 */
type CreateDeeplinkOptions = CreateScriptCommandDeeplinkOptions | CreateExtensionDeeplinkOptions;
export function createScriptCommandDeeplink(options: CreateScriptCommandDeeplinkOptions): string;
export function createExtensionDeeplink(options: CreateExtensionDeeplinkOptions): string;
/**
 * Creates a deeplink to a script command or extension.
 */
export function createDeeplink(options: CreateDeeplinkOptions): string;
/**
 * Executes a SQL query on a local SQLite database and returns the query result in JSON format.
 *
 * @param databasePath - The path to the SQLite database file.
 * @param query - The SQL query to execute.
 * @returns A Promise that resolves to an array of objects representing the query results.
 *
 * @example
 * ```typescript
 * import { closeMainWindow, Clipboard } from "@raycast/api";
 * import { executeSQL } from "@raycast/utils";
 *
 * type Message = { body: string; code: string };
 *
 * const DB_PATH = "/path/to/chat.db";
 *
 * export default async function Command() {
 *   const query = `SELECT body, code FROM ...`
 *
 *   const messages = await executeSQL<Message>(DB_PATH, query);
 *
 *   if (messages.length > 0) {
 *     const latestCode = messages[0].code;
 *     await Clipboard.paste(latestCode);
 *     await closeMainWindow();
 *   }
 * }
 * ```
 */
export function executeSQL<T = unknown>(databasePath: string, query: string): Promise<T[]>;
type AppleScriptOptions = {
    /**
     * By default, `runAppleScript` returns its results in human-readable form: strings do not have quotes around them, characters are not escaped, braces for lists and records are omitted, etc. This is generally more useful, but can introduce ambiguities. For example, the lists `{"foo", "bar"}` and `{{"foo", {"bar"}}}` would both be displayed as ‘foo, bar’. To see the results in an unambiguous form that could be recompiled into the same value, set `humanReadableOutput` to `false`.
     *
     * @default true
     */
    humanReadableOutput?: boolean;
    /**
     * Whether the script is using [`AppleScript`](https://developer.apple.com/library/archive/documentation/AppleScript/Conceptual/AppleScriptLangGuide/introduction/ASLR_intro.html#//apple_ref/doc/uid/TP40000983) or [`JavaScript`](https://developer.apple.com/library/archive/releasenotes/InterapplicationCommunication/RN-JavaScriptForAutomation/Articles/Introduction.html#//apple_ref/doc/uid/TP40014508-CH111-SW1).
     *
     * @default "AppleScript"
     */
    language?: "AppleScript" | "JavaScript";
    /**
     * A Signal object that allows you to abort the request if required via an AbortController object.
     */
    signal?: AbortSignal;
    /** If timeout is greater than `0`, the parent will send the signal `SIGTERM` if the child runs longer than timeout milliseconds.
     *
     * @default 10000
     */
    timeout?: number;
};
/**
 * Executes an AppleScript script.
 *
 * @example
 * ```typescript
 * import { showHUD } from "@raycast/api";
 * import { runAppleScript, showFailureToast } from "@raycast/utils";
 *
 * export default async function () {
 *   try {
 *     const res = await runAppleScript(
 *       `
 *       on run argv
 *         return "hello, " & item 1 of argv & "."
 *       end run
 *       `,
 *       ["world"]
 *     );
 *     await showHUD(res);
 *   } catch (error) {
 *     showFailureToast(error, { title: "Could not run AppleScript" });
 *   }
 * }
 * ```
 */
export function runAppleScript<T = string>(script: string, options?: AppleScriptOptions & {
    parseOutput?: ParseExecOutputHandler<T, string, AppleScriptOptions>;
}): Promise<string>;
export function runAppleScript<T = string>(script: string, 
/**
 * The arguments to pass to the script.
 */
args: string[], options?: AppleScriptOptions & {
    parseOutput?: ParseExecOutputHandler<T, string, AppleScriptOptions>;
}): Promise<string>;
type PowerShellScriptOptions = {
    /**
     * A Signal object that allows you to abort the request if required via an AbortController object.
     */
    signal?: AbortSignal;
    /** If timeout is greater than `0`, the parent will send the signal `SIGTERM` if the child runs longer than timeout milliseconds.
     *
     * @default 10000
     */
    timeout?: number;
};
/**
 * Executes a PowerShell script.
 *
 * @example
 * ```typescript
 * import { showHUD } from "@raycast/api";
 * import { runPowerShellScript, showFailureToast } from "@raycast/utils";
 *
 * export default async function () {
 *   try {
 *     const res = await runPowerShellScript(
 *       `
 *       Write-Host "hello, world."
 *       `,
 *     );
 *     await showHUD(res);
 *   } catch (error) {
 *     showFailureToast(error, { title: "Could not run PowerShell" });
 *   }
 * }
 * ```
 */
export function runPowerShellScript<T = string>(script: string, options?: PowerShellScriptOptions & {
    parseOutput?: ParseExecOutputHandler<T, string, PowerShellScriptOptions>;
}): Promise<string>;
/**
 * Wraps a function with caching functionality using Raycast's Cache API.
 * Allows for caching of expensive functions like paginated API calls that rarely change.
 *
 * @param fn - The async function to cache results from
 * @param options - Optional configuration for the cache behavior
 * @param options.validate - Optional validation function for cached data
 * @param options.maxAge - Maximum age of cached data in milliseconds
 * @returns An async function that returns the result of the function, either from cache or fresh execution
 *
 * @example
 * ```ts
 * const cachedFunction = withCache(fetchExpensiveData, {
 *   maxAge: 5 * 60 * 1000 // Cache for 5 minutes
 * });
 *
 * const result = await cachedFunction(query);
 * ```
 */
export function withCache<Fn extends (...args: any) => Promise<any>>(fn: Fn, options?: {
    /** function that receives the cached data and returns a boolean depending on whether the data is still valid or not. */
    validate?: (data: Awaited<ReturnType<Fn>>) => boolean;
    /** Maximum age of cached data in milliseconds after which the data will be considered invalid */
    maxAge?: number;
}): Fn & {
    clearCache: () => void;
};

//# sourceMappingURL=types.d.ts.map
